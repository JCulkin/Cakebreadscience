<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Geometry Matcher</title>
  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;font-family:Courier New,monospace;background:linear-gradient(135deg,#0a0a1a,#1a0a2e);color:#0f0}
    body{display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px}
    .ui{position:absolute;left:8px;top:8px;font-size:12px}
    a.back{color:#0f0;text-decoration:none;border-bottom:1px solid #0f0}
    .game-container{display:flex;gap:24px;align-items:center;justify-content:center}
    canvas{border:2px solid #0f0;background:#000;border-radius:4px}
    .controls{text-align:center;font-size:13px}
    button{margin:6px;padding:10px 16px;border-radius:6px;border:1px solid #0f0;background:#0a1a0a;color:#0f0;font-weight:bold;cursor:pointer;font-family:Courier New,monospace;transition:all 200ms}
    button:hover{background:#0f0;color:#000;box-shadow:0 0 12px #0f0}
    button:active{transform:scale(0.95)}
    #score{margin-top:10px;color:#0f0;font-weight:bold;font-size:14px}
    #hint{font-size:11px;color:#0f0;opacity:0.7;margin-top:8px;max-width:200px}
  </style>
</head>
<body>
  
  <div class="game-container">
    <div>
      <canvas id="gameCanvas" width="240" height="240"></canvas>
      <div class="controls">
        <div id="score">Score: 0</div>
        <div id="hint" style="display:none"></div>
      </div>
    </div>
  </div>
  <div style="position:absolute;bottom:12px;left:12px;right:12px;display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
    <button id="btn-match">✓ Match</button>
    <button id="btn-nomatch">✗ Different</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const hintEl = document.getElementById('hint');
    
    let score = 0;
    let currentChallenge = null;
    
    // Pattern types
    const patterns = ['grid', 'spiral', 'radial', 'wave', 'diamond', 'hexagon'];
    
    class Pattern {
      constructor(type, rotation = 0, color = '#0f0', symmetry = 1) {
        this.type = type;
        this.rotation = rotation;
        this.color = color;
        this.symmetry = symmetry;
      }
      
      draw(ctx, x, y, size) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        
        switch(this.type) {
          case 'grid':
            this.drawGrid(ctx, size);
            break;
          case 'spiral':
            this.drawSpiral(ctx, size);
            break;
          case 'radial':
            this.drawRadial(ctx, size);
            break;
          case 'wave':
            this.drawWave(ctx, size);
            break;
          case 'diamond':
            this.drawDiamond(ctx, size);
            break;
          case 'hexagon':
            this.drawHexagon(ctx, size);
            break;
        }
        ctx.restore();
      }
      
      drawGrid(ctx, size) {
        const spacing = 20;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 1;
        for(let i = -size; i <= size; i += spacing) {
          ctx.beginPath();
          ctx.moveTo(i, -size);
          ctx.lineTo(i, size);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(-size, i);
          ctx.lineTo(size, i);
          ctx.stroke();
        }
      }
      
      drawSpiral(ctx, size) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let a = 0; a < Math.PI * 6; a += 0.1) {
          const r = (a / (Math.PI * 6)) * size;
          const x = Math.cos(a) * r;
          const y = Math.sin(a) * r;
          if(a === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      
      drawRadial(ctx, size) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 1;
        const rays = 8;
        for(let i = 0; i < rays; i++) {
          const angle = (i / rays) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(angle) * size, Math.sin(angle) * size);
          ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      drawWave(ctx, size) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let x = -size; x <= size; x += 2) {
          const y = Math.sin(x / 10) * 30;
          if(x === -size) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      
      drawDiamond(ctx, size) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(size, 0);
        ctx.lineTo(0, size);
        ctx.lineTo(-size, 0);
        ctx.closePath();
        ctx.stroke();
        
        const inner = size * 0.5;
        ctx.beginPath();
        ctx.moveTo(0, -inner);
        ctx.lineTo(inner, 0);
        ctx.lineTo(0, inner);
        ctx.lineTo(-inner, 0);
        ctx.closePath();
        ctx.stroke();
      }
      
      drawHexagon(ctx, size) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2;
          const x = Math.cos(angle) * size;
          const y = Math.sin(angle) * size;
          if(i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
    
    function generateChallenge() {
      const chaos = window._chaosIntensity || 0;
      const type1 = patterns[Math.floor(Math.random() * patterns.length)];
      const type2 = patterns[Math.floor(Math.random() * patterns.length)];
      const rot1 = Math.random() * Math.PI * 2;
      
      // base chance of match, reduced as chaos increases
      const baseMatch = 0.6;
      const matchProb = Math.max(0.15, baseMatch - (chaos * 0.04));
      const isMatch = Math.random() < matchProb;

      // rotation variance increases with chaos
      const rotVariance = Math.min(Math.PI, 0.8 + chaos * 0.15);
      const rot2 = isMatch ? rot1 : rot1 + (Math.random() * rotVariance + Math.PI * 0.05);
      
      // choose patterns: if chaos is high, prefer different types even when isMatch true
      const typeForSecond = (isMatch && Math.random() > Math.min(0.9, chaos*0.08)) ? type1 : type2;

      const pattern1 = new Pattern(type1, rot1, '#0f0', 1);
      const pattern2 = new Pattern(isMatch ? type1 : typeForSecond, rot2, '#0f0', 1);
      
      return { pattern1, pattern2, isMatch };
    }
    
    function drawChallenge() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw border
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 1;
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
      
      // Draw dividing line
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      
      // Draw patterns
      currentChallenge.pattern1.draw(ctx, canvas.width * 0.25, canvas.height * 0.5, 50);
      currentChallenge.pattern2.draw(ctx, canvas.width * 0.75, canvas.height * 0.5, 50);
      
      // Update hint
      hintEl.textContent = 'Are the patterns SAME or DIFFERENT?';
    }
    
    function nextRound() {
      currentChallenge = generateChallenge();
      drawChallenge();
    }
    
    function sendScore() {
      try {
        parent.postMessage({type: 'score', id: 'color', score: score}, '*');
      } catch(e) {}
    }
    
    document.getElementById('btn-match').addEventListener('click', () => {
      if(currentChallenge.isMatch) {
        score += 1;
        hintEl.textContent = '✓ Correct!';
      } else {
        score = Math.max(0, score - 1);
        hintEl.textContent = '✗ Wrong!';
      }
      scoreEl.textContent = 'Score: ' + score;
      sendScore();
      setTimeout(nextRound, 300);
    });
    
    document.getElementById('btn-nomatch').addEventListener('click', () => {
      if(!currentChallenge.isMatch) {
        score += 1;
        hintEl.textContent = '✓ Correct!';
      } else {
        score = Math.max(0, score - 1);
        hintEl.textContent = '✗ Wrong!';
      }
      scoreEl.textContent = 'Score: ' + score;
      sendScore();
      setTimeout(nextRound, 300);
    });
    
    // Initialize
    nextRound();
    sendScore();

    // chaos messages from parent
    let speedMultiplier = 1;
    let invertMouse = false;
    window.addEventListener('message', e=>{
      try{
        const d = e.data;
        if(d && d.type === 'chaos'){
          speedMultiplier = d.speedMultiplier || 1;
          invertMouse = !!d.invertMouse;
          // make matches rarer and rotations more extreme as intensity grows
          if(d.intensity){
            // store for generateChallenge
            window._chaosIntensity = d.intensity;
          }
        }
        if(d && d.type === 'reset'){
          speedMultiplier = 1; invertMouse = false; window._chaosIntensity = 0;
        }
      }catch(err){}
    });
  </script>
</body>
</html>
