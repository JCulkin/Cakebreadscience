<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Dodger</title>
  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;font-family:Courier New,monospace;background:#081218;color:#0f0}
    body{display:flex;align-items:center;justify-content:center;flex-direction:column}
    canvas{background:#071024;border:2px solid #0f0;border-radius:6px;display:block}
    .ui{position:absolute;left:8px;top:8px;font-size:12px}
    a.back{color:#0f0;text-decoration:none}
  </style>
  </head>
<body>
  <canvas id="c"></canvas>
  <script>
    const cvs=document.getElementById('c'),ctx=cvs.getContext('2d');
    function resizeCanvas(){ cvs.width = window.innerWidth - 20; cvs.height = Math.max(320, window.innerHeight - 40); }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    const player={x:cvs.width/2,y:cvs.height-28,w:60,h:14};
    const enemies=[]; let score=0;
    // chaos-controlled parameters
    let speedMultiplier = 1;
    let invertMouse = false;
    // spawn an enemy with random width and slower speed (easier)
    function spawnEnemy(){ enemies.push({x:Math.random()*(cvs.width-40)+20,y:-20,vy:0.6 + Math.random()*1.2,w:10+Math.random()*12}); }
    for(let i=0;i<3;i++) spawnEnemy();
    // notify parent of initial score
    try{ parent.postMessage({type:'score', id:'dodger', score: score}, '*'); }catch(e){}
    document.addEventListener('mousemove',e=>{
      const r=cvs.getBoundingClientRect();
      const mx = e.clientX - r.left;
      const target = invertMouse ? (cvs.width - mx) : mx;
      player.x = Math.max(10, Math.min(cvs.width-10, target));
    })
    function loop(){
      ctx.clearRect(0,0,cvs.width,cvs.height);
      // draw player
      ctx.fillStyle='#0f0'; ctx.fillRect(player.x-player.w/2,player.y-player.h/2,player.w,player.h);
      // enemies
      enemies.forEach((en,i)=>{ en.y += (en.vy * (window._speedMultiplier || 1)); ctx.fillStyle='#ff4444'; ctx.fillRect(en.x-en.w/2,en.y-en.w/2,en.w,en.w); if(en.y>cvs.height+20) { enemies.splice(i,1); score++; try{ parent.postMessage({type:'score', id:'dodger', score: score}, '*'); }catch(e){} spawnEnemy(); } if(Math.hypot(en.x-player.x,en.y-player.y) < (en.w/2+player.w/2)) { gameOver(); }});
      ctx.fillStyle='#0f0'; ctx.fillText('Score: '+score,10,20);
      requestAnimationFrame(loop);
    }
    function gameOver(){ alert('Game Over - Score: '+score); try{ parent.postMessage({type:'score', id:'dodger', score: 0}, '*'); }catch(e){} score=0; enemies.length=0; for(let i=0;i<5;i++) spawnEnemy(); }
    loop();

    // listen for chaos messages from parent
    window.addEventListener('message', e=>{
      try{
        const d = e.data;
        if(d && d.type === 'chaos'){
          speedMultiplier = d.speedMultiplier || 1;
          invertMouse = !!d.invertMouse;
          // adjust enemies speed
          enemies.forEach(en=> en.vy = Math.abs(en.vy) * speedMultiplier);
        }
        if(d && d.type === 'reset'){
          speedMultiplier = 1; invertMouse = false;
        }
      }catch(err){}
    });
  </script>
</body>
</html>
