<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>üïπÔ∏è SECRET ARACDE</title>
    <style>
        html,body{overflow-x:hidden}
        body{font-family: 'Courier New', monospace;background:linear-gradient(135deg,#040404,#0b1020);color:#00ff00;margin:0;min-height:100vh}
        .wrap{max-width:100%;width:100%;margin:24px 8px;padding:12px;box-sizing:border-box}
        header{text-align:center;margin-bottom:20px}
        a.back{color:#00ff00;text-decoration:none;border:1px solid #00ff00;padding:8px 12px;border-radius:6px;display:inline-block}
        h1{font-size:2.4rem;margin:12px 0}
        .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:16px;margin-top:20px}
        .card{background:rgba(0,40,0,0.6);border:1px solid #00ff00;padding:18px;border-radius:8px;text-align:center}
        .card a{display:inline-block;margin-top:12px;padding:8px 12px;background:#00ff00;color:#000;border-radius:6px;text-decoration:none;font-weight:bold}
        .hint{opacity:0.8;font-size:0.9rem;margin-top:8px}
        footer{text-align:center;margin-top:30px;opacity:0.8}
    </style>
    <style>
        /* smooth transitions when background changes */
        body{transition: background 350ms ease, filter 350ms ease}
        /* ensure iframes transform from top edge to avoid overlapping neighbors */
        iframe{transform-origin:50% 0;display:block;box-sizing:border-box;min-width:0}
        .card, #games-row, .game-frame-wrapper-bubble, .game-frame-wrapper-dodger, .game-frame-wrapper-color { box-sizing: border-box }
        @keyframes pulse{0%{opacity:1;transform:scale(1)}50%{opacity:0.6;transform:scale(1.05)}100%{opacity:1;transform:scale(1)}}
        @keyframes shake{0%{transform:translate(0,0)}10%{transform:translate(-8px,-8px)}20%{transform:translate(8px,8px)}30%{transform:translate(-8px,8px)}40%{transform:translate(8px,-8px)}50%{transform:translate(0,0)}60%{transform:translate(-4px,-4px)}70%{transform:translate(4px,4px)}80%{transform:translate(-4px,4px)}90%{transform:translate(4px,-4px)}100%{transform:translate(0,0)}}
        @keyframes driftLeft{0%{transform:translateX(0)}50%{transform:translateX(-60px)}100%{transform:translateX(0)}}
        @keyframes driftRight{0%{transform:translateX(0)}50%{transform:translateX(60px)}100%{transform:translateX(0)}}
        @keyframes driftDown{0%{transform:translateY(0)}50%{transform:translateY(60px)}100%{transform:translateY(0)}}
        @keyframes driftUp{0%{transform:translateY(0)}50%{transform:translateY(-60px)}100%{transform:translateY(0)}}
        @keyframes bounce{0%{transform:scale(0.3);opacity:0}50%{transform:scale(1.1)}100%{transform:scale(1);opacity:1}}
        @keyframes fadeOut{0%{opacity:1}100%{opacity:0}}
    </style>
</head>
<body>
        <div id="scoreboard" style="position:fixed;top:12px;left:12px;display:flex;gap:12px;align-items:center;background:rgba(0,0,0,0.9);padding:8px 12px;border-radius:8px;border:2px solid #00ff00;z-index:99999;backdrop-filter:blur(8px);box-shadow:0 0 12px rgba(0,255,0,0.35);pointer-events:auto;">
            <div style="padding:6px 10px;background:rgba(0,0,0,0.6);border:1px solid #ff0;border-radius:6px;font-size:0.95em;color:#ff0;font-weight:bold;text-shadow:0 0 6px #ff0" id="chaos-level">CALM</div>
            <a class="back" href="../index.html" style="color:#00ff00;text-decoration:none;padding:6px 8px;border:1px solid rgba(0,255,0,0.12);border-radius:6px;">‚Üê MAIN</a>
        </div>

        <div id="inventory-box" style="position:fixed;top:12px;right:12px;display:flex;flex-direction:column;gap:8px;background:rgba(0,0,0,0.92);padding:12px;border-radius:10px;border:2px solid #00aa00;z-index:99999;backdrop-filter:blur(8px);box-shadow:0 0 18px rgba(0,170,0,0.45);max-width:480px;width:min(46vw,480px);pointer-events:auto;">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
                <div style="color:#00aa00;font-weight:bold;font-size:0.95em;text-shadow:0 0 4px #00aa00">üì¶ INVENTORY</div>
                <div id="inventory-badge" style="font-size:0.9em;color:#00ff00;background:rgba(0,0,0,0.35);padding:4px 8px;border-radius:6px;border:1px solid rgba(0,170,0,0.2)">0</div>
            </div>
            <div id="inventory-notif" style="position:relative;min-height:0"></div>
            <div id="inventory-grid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(56px,1fr));gap:8px;padding:8px;background:rgba(0,20,0,0.36);border-radius:6px;border:1px solid rgba(0,170,0,0.28);align-items:center;justify-items:center">
            </div>
            <div style="font-size:0.9em;color:#00ff00;text-align:center" id="inventory-count">Items: 0</div>
            <div id="inventory-mini" style="display:none;flex-direction:column;gap:8px;margin-top:6px">
                <button id="inventory-play" style="background:#00aa00;color:#001;padding:8px 12px;border-radius:8px;border:1px solid rgba(0,120,0,0.6);font-weight:bold;cursor:pointer">‚ñ∂ PLAY MINI-GAME</button>
                <canvas id="inventory-canvas" width="360" height="140" style="width:100%;height:120px;border-radius:6px;border:1px solid rgba(0,170,0,0.2);background:rgba(0,0,0,0.55);display:block"></canvas>
                <div id="inventory-mini-score" style="color:#0f0;text-align:center;font-size:0.95em">Mini Score: 0</div>
            </div>
        </div>

    <div class="wrap">
        <header>
            <h1>üïπÔ∏è SECRET ARACDE</h1>
            <a class="back" href="../index.html">‚Üê BACK TO MAIN</a>
            <div class="hint">A hidden collection of small games and demos.</div>
        </header>

        <div id="bacon" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:120px;z-index:9998;opacity:0;pointer-events:none;transition:none;text-shadow:0 0 20px rgba(255,100,0,0.8)">ü•ì</div>

        <div class="grid" id="games-row" style="display:flex;flex-wrap:nowrap;gap:12px;align-items:flex-start;margin-top:48px;position:relative;transition:transform 150ms ease-out;">
            <div id="game-frame-wrapper-bubble" style="flex:1 1 0;min-width:0;position:relative;overflow:visible;">
                <div class="card" style="flex:1;width:100%;overflow:visible;">
                    <h3>Bubble Pop</h3>
                    <iframe id="frame-bubble" src="secret-games/bubble-pop.html" style="width:100%;height:420px;border:0;border-radius:8px;display:block;transition:transform 200ms ease-out;" title="Bubble Pop"></iframe>
                </div>
            </div>
            <div id="game-frame-wrapper-dodger" style="flex:1 1 0;min-width:0;position:relative;overflow:visible;">
                <div class="card" style="flex:1;width:100%;overflow:visible;">
                    <h3>Pixel Dodger</h3>
                    <iframe id="frame-dodger" src="secret-games/dodger.html" style="width:100%;height:420px;border:0;border-radius:8px;display:block;transition:transform 200ms ease-out;" title="Pixel Dodger"></iframe>
                </div>
            </div>
            <div id="game-frame-wrapper-color" style="flex:1 1 0;min-width:0;position:relative;overflow:visible;">
                <div class="card" style="flex:1;width:100%;overflow:visible;">
                    <h3>Geometry Matcher</h3>
                    <iframe id="frame-color" src="secret-games/color-match.html" style="width:100%;height:420px;border:0;border-radius:8px;display:block;transition:transform 200ms ease-out;" title="Geometry Matcher"></iframe>
                </div>
            </div>

        
    </div>
    <script>
        // Arcade behavior: listen for iframe scores and escalate chaos as product increases
        (function(){
            const body = document.body;
            const main = document.querySelector('.wrap');
            const presets = [
                'linear-gradient(135deg,#040404,#0b1020)',
                'radial-gradient(circle at 20% 20%, #ff0099, transparent 30%), radial-gradient(circle at 80% 80%, #00ffff, transparent 30%), #020202',
                'linear-gradient(45deg,#ff6a00,#ee0979)',
                'linear-gradient(90deg,#00f,#0ff)',
                'linear-gradient(120deg,#141e30,#243b55)',
                'repeating-linear-gradient(45deg,#0b0 0 10px,#030 10px 20px)'
            ];

            const scores = { bubble: 0, dodger: 0, color: 0 };
            const ids = { bubble: 'score-bubble', dodger: 'score-dodger', color: 'score-color' };
            
            // Item name pool (ridiculous artifact names)
            const itemNames = {
                'ü•ì': ['Crispy Relic of Breakfast Past', 'Sacred Pork Strip Fossil', 'The Eternal Bacon Prophecy', 'Gilded Smokey Cured Wonder', 'Strips of Infinite Sizzle', 'The Bacon Totem of Seven Circles'],
                'ü•ìü•ì': ['Double Bacon Paradox Artifact', 'The Twin Strips of Destiny', 'Bacon Duo Infinity Stone', 'Mirror Crisp Reality Breach', 'The Doubled Deliciousness Singularity', 'Twins of the Smokey Realm'],
                '‚ò¢Ô∏è': ['Uranium of Perpetual Glowing', 'The Isotope Heart of Tomorrow', 'Radioactive Stone of Wonder', 'Glowing Cube of Ancient Science', 'The Element That Refused to Decay', 'Chunk o\'Eternal Radiance'],
                'üåç': ['The Entire Sphere Achievement', 'Whole Planet Achievement Token', 'Planetary Completionist Badge', 'The Big Blue Marble Prize', 'Achievement: You Own Earth Now', 'The Existence Consolidation Artifact'],
                '3Ô∏è‚É£': ['The Number Three Incarnate', 'Trilogy Completion Emblem', 'The Holy Numeral', 'Trinity Trinket of Threes', 'Numeric Essence of Trio', 'The Mystical Thrice Token'],
                'üëë': ['Crown of Questionable Authority', 'Royalty Simulator Badge', 'The Plastic Monarchy', 'King of Absolutely Nothing', 'Throne Seat Certificate', 'Imaginary Kingdom Deed'],
                'üçÑ': ['Mushroom of Temporal Confusion', 'The Fungal Time Distortion', 'Spore of Forgotten Memories', 'Cap of Dimensional Shift', 'The Fungal Consciousness Fragment', 'Mycelial Network Node'],
                'üíé': ['Diamond of Minor Importance', 'Gem Nobody Asked For', 'The Slightly Sparkly Rock', 'Crystal of Dubious Value', 'Shiny Object Syndrome Prize', 'The Glitter That Lasted'],
                '‚ö°': ['Lightning in a Bottle But We Lost the Bottle', 'Thunder Essence Uncork Protocol', 'Static Electricity Captured Forever', 'Bolt of Regret', 'The Storm\'s Angry Moment', 'Zap Jar Achievement Unlocked'],
                'üé≤': ['Die of Randomness Confirmed', 'Cube of Uncertain Outcomes', 'The Probability Dodecahedron', 'Fate\'s Little Plastic Friend', 'Luck Crystallization Artifact', 'Chaos Geometry Token'],
                'üîÆ': ['Crystal Ball of Vague Truths', 'Orb of Misleading Predictions', 'The Glass Sphere of Maybe', 'Fortune Teller\'s Regret Device', 'Fate\'s Fog Machine', 'The Cloudy Decision Maker'],
                'üëΩ': ['Extraterrestrial Visitor Souvenir', 'Alien Tourist Tchotchke', 'The Green Little Buddy', 'UFO Gift Shop Item', 'Interstellar Pen Pal Token', 'E.T. Phone Home Receipt'],
                'üé≠': ['Drama Mask of Existential Crisis', 'Comedy Tragedy Emotional Roller Coaster', 'Theater Kid Energy Crystallized', 'The Mask of Questionable Intent', 'Performance Art Gone Wrong', 'Stage Fright Embodied'],
                'üíÄ': ['Skull of Your Impending Doom (Maybe)', 'Death\'s Fashion Accessory', 'Skeleton Key That Opens Nothing', 'The Fiery Skull of Mt. Forevermore', 'Memento Mori Merchandise', 'Reaper\'s Gift Shop Exclusive'],
                'üåà': ['Prism of Contradictory Promises', 'Spectrum of False Hope', 'The Pot\'s Empty But We Tried', 'Multicolor Confusion Cloud', 'Happiness Extraction Failed Device', 'The Chromatic Illusion']
            };
            
            // Notification system (top-center, longer-lived so it doesn't sit on inventory)
            function showUnlockNotification(item, name){
                const container = document.body;
                const notif = document.createElement('div');
                notif.className = 'unlock-notification';
                notif.style.position = 'fixed';
                notif.style.top = '72px';
                notif.style.left = '50%';
                notif.style.transform = 'translateX(-50%)';
                notif.style.background = 'rgba(12,12,12,0.96)';
                notif.style.border = '2px solid #ffd700';
                notif.style.borderRadius = '12px';
                notif.style.padding = '10px 16px';
                notif.style.textAlign = 'center';
                notif.style.zIndex = '99998';
                notif.style.pointerEvents = 'none';
                notif.style.boxShadow = '0 0 28px rgba(255,215,0,0.35)';
                notif.style.animation = 'bounce 0.35s ease-out';
                notif.innerHTML = `<div style="font-size:34px;line-height:1">${item}</div><div style="color:#ffd700;font-weight:bold;font-size:0.95em;margin-top:6px">${name}</div>`;
                container.appendChild(notif);

                // medium celebratory particles (somewhere near top)
                for(let i=0;i<12;i++) spawnParticle(1.8 + Math.random());

                // gentle page pulse around center area
                const center = document.querySelector('.wrap');
                if(center){ center.style.transition = 'transform 200ms'; center.style.transform = 'translateY(-4px)'; setTimeout(()=>{ center.style.transform = ''; }, 260); }

                // stay longer (5s)
                setTimeout(()=>{ try{ notif.style.transition = 'opacity 400ms'; notif.style.opacity = '0'; setTimeout(()=>{ try{ notif.remove(); }catch(e){} }, 420); }catch(e){} }, 5000);
            }
            
            // Inventory system
            const itemPool = ['ü•ì', 'ü•ìü•ì', '‚ò¢Ô∏è', 'üåç', '3Ô∏è‚É£', 'üëë', 'üçÑ', 'üíé', '‚ö°', 'üé≤', 'üîÆ', 'üëΩ', 'üé≠', 'üíÄ', 'üåà'];
            const inventory = [];
            const awardThresholds = { individual: [5, 10, 25, 50, 100, 250], product: [10, 50, 250, 1000] };
            const previousScores = { bubble: 0, dodger: 0, color: 0, product: 0 };
            const lastAwardedAt = { bubble: {}, dodger: {}, color: {}, product: {} };
            
            function addItemToInventory(){
                const item = itemPool[Math.floor(Math.random() * itemPool.length)];
                const itemName = itemNames[item][Math.floor(Math.random() * itemNames[item].length)];
                inventory.push({item, name: itemName});
                showUnlockNotification(item, itemName);
                // small page explosion for extra feedback
                try{ spawnPageExplosion(); }catch(e){}
                updateInventoryDisplay();
            }
            
            function removeRandomItem(){
                if(inventory.length > 0){
                    inventory.splice(Math.floor(Math.random() * inventory.length), 1);
                    updateInventoryDisplay();
                }
            }
            
            function updateInventoryDisplay(){
                const grid = document.getElementById('inventory-grid');
                const count = document.getElementById('inventory-count');
                const badge = document.getElementById('inventory-badge');
                if(grid) grid.innerHTML = inventory.map((itemObj, idx)=>`<div data-idx="${idx}" style="font-size:30px;padding:6px;text-align:center;cursor:default;transition:transform 120ms;border-radius:6px" title="${itemObj.name}">${itemObj.item}</div>`).join('');
                if(count) count.textContent = `Items: ${inventory.length}`;
                if(badge) badge.textContent = inventory.length;

                // Auto-adjust icon sizes when inventory grows
                if(grid){
                    const els = grid.querySelectorAll('[data-idx]');
                    els.forEach(el=>{
                        if(inventory.length >= 20) el.style.fontSize = '22px';
                        else if(inventory.length >= 12) el.style.fontSize = '26px';
                        else el.style.fontSize = '30px';
                    });
                }

                // Show mini-game UI when inventory gets big
                const mini = document.getElementById('inventory-mini');
                if(inventory.length >= 10){ 
                    if(mini) { 
                        mini.style.display = 'flex'; 
                        // start the mini-game after a short delay so DOM updates/render happens
                        if(!miniGame.active){ 
                            setTimeout(()=>{ try{ if(!miniGame.active) startMiniGame(); }catch(e){} }, 120);
                        }
                    } 
                } else { if(mini) mini.style.display = 'none'; }

                // Ensure play button is wired (safe to call multiple times)
                const play = document.getElementById('inventory-play');
                if(play && !play._wired){ play.addEventListener('click', ()=>{ startMiniGame(); }); play._wired = true; }
            }
            
            function checkAndAwardItems(){
                const grand = calcGrand();
                // Check individual game scores
                ['bubble', 'dodger', 'color'].forEach(game=>{
                    const currScore = scores[game];
                    if(currScore > previousScores[game]){
                        awardThresholds.individual.forEach(threshold=>{
                            if(!lastAwardedAt[game][threshold] && currScore >= threshold){
                                addItemToInventory();
                                lastAwardedAt[game][threshold] = true;
                            }
                        });
                    }
                    previousScores[game] = currScore;
                });
                // Check product thresholds
                if(grand > previousScores.product){
                    awardThresholds.product.forEach(threshold=>{
                        if(!lastAwardedAt.product[threshold] && grand >= threshold){
                            addItemToInventory();
                            lastAwardedAt.product[threshold] = true;
                        }
                    });
                }
                previousScores.product = grand;
                
                    // Detect score drops (death) ‚Äî remove an item
                    let anyDropped = false;
                    ['bubble', 'dodger', 'color'].forEach(game=>{
                        if(scores[game] < previousScores[game] && previousScores[game] > 0){
                            anyDropped = true;
                        }
                    });
                    if(anyDropped && inventory.length > 0){
                        removeRandomItem();
                    }
                }

                // Mini-game system (fresh rewrite)
                const miniGame = { active: false, canvas: null, ctx: null, player: null, items: [], score: 0, rafId: null, keyHandler: null, expandMode: false };

                function startMiniGame(){
                    if(miniGame.active) return;
                    miniGame.canvas = document.getElementById('inventory-canvas');
                    if(!miniGame.canvas) { console.error('Canvas not found'); return; }
                    
                    miniGame.ctx = miniGame.canvas.getContext('2d');
                    miniGame.active = true;
                    miniGame.score = 0;
                    miniGame.items = [];
                    miniGame.expandMode = false;
                    document.getElementById('inventory-mini-score').textContent = 'Mini Score: 0';
                    
                    // spawn random items on canvas
                    for(let i = 0; i < 5; i++){
                        miniGame.items.push({
                            x: Math.random() * (miniGame.canvas.width - 40) + 20,
                            y: Math.random() * (miniGame.canvas.height - 40) + 20,
                            size: 20,
                            emoji: ['ü•ì','‚ò¢Ô∏è','üåç','üëë','üíé','‚ö°'][Math.floor(Math.random()*6)]
                        });
                    }
                    
                    miniGame.player = { x: miniGame.canvas.width/2, y: miniGame.canvas.height/2, radius: 12, dx: 0, dy: 0, speed: 4 };
                    
                    miniGame.keyHandler = function(e){
                        if(e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') miniGame.player.dy = -1;
                        if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') miniGame.player.dy = 1;
                        if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') miniGame.player.dx = -1;
                        if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') miniGame.player.dx = 1;
                    };
                    
                    window.addEventListener('keydown', miniGame.keyHandler);
                    
                    function renderMiniGame(){
                        if(!miniGame.active) return;
                        const c = miniGame.canvas;
                        const ctx = miniGame.ctx;
                        
                        // clear
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, c.width, c.height);
                        
                        // update player
                        const p = miniGame.player;
                        p.x += p.dx * p.speed;
                        p.y += p.dy * p.speed;
                        p.x = Math.max(p.radius, Math.min(c.width - p.radius, p.x));
                        p.y = Math.max(p.radius, Math.min(c.height - p.radius, p.y));
                        
                        // draw items
                        miniGame.items.forEach(item => {
                            ctx.font = item.size + 'px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(item.emoji, item.x, item.y);
                        });
                        
                        // draw player
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // no transient prompt: game starts immediately when inventory reached threshold
                        
                        // collision
                        for(let i = miniGame.items.length - 1; i >= 0; i--){
                            const item = miniGame.items[i];
                            const dist = Math.hypot(item.x - p.x, item.y - p.y);
                            if(dist < p.radius + 15){
                                miniGame.items.splice(i, 1);
                                miniGame.score++;
                                document.getElementById('inventory-mini-score').textContent = 'Mini Score: ' + miniGame.score;
                                spawnParticle(3);
                                
                                // win condition: all collected
                                if(miniGame.items.length === 0){
                                    startExpandMode();
                                    return;
                                }
                            }
                        }
                        
                        miniGame.rafId = requestAnimationFrame(renderMiniGame);
                    }
                    
                    renderMiniGame();
                    setTimeout(endMiniGame, 30000); // 30 second timeout
                }
                
                function startExpandMode(){
                    miniGame.expandMode = true;
                    const canvas = miniGame.canvas;
                    const inventoryMini = document.getElementById('inventory-mini');

                    // Original position/dimensions of the inventory mini box
                    const startRect = inventoryMini.getBoundingClientRect();
                    const originalWidth = startRect.width;
                    const originalHeight = startRect.height;
                    const originalLeft = startRect.left;
                    const originalTop = startRect.top;

                    // Target: overlay the geometry game if available, otherwise expand downwards to bottom of viewport
                    const colorWrapper = document.getElementById('game-frame-wrapper-color');
                    const targetRect = colorWrapper ? colorWrapper.getBoundingClientRect() : { left: 0, top: window.innerHeight/3, width: window.innerWidth, height: window.innerHeight/2 };

                    const targetLeft = targetRect.left;
                    const targetTop = targetRect.top;
                    const targetWidth = targetRect.width;
                    const targetHeight = targetRect.height;

                    const expandDuration = 800; // ms
                    const startTime = Date.now();

                    // fix inventoryMini to viewport so it can move freely
                    inventoryMini.style.position = 'fixed';
                    inventoryMini.style.left = originalLeft + 'px';
                    inventoryMini.style.top = originalTop + 'px';
                    inventoryMini.style.zIndex = '9999';
                    inventoryMini.style.borderRadius = '6px';

                    function expand(){
                        const t = Math.min(1, (Date.now() - startTime) / expandDuration);
                        const eased = 1 - Math.pow(1 - t, 3);

                        const curLeft = originalLeft + (targetLeft - originalLeft) * eased;
                        const curTop = originalTop + (targetTop - originalTop) * eased;
                        const curWidth = originalWidth + (targetWidth - originalWidth) * eased;
                        const curHeight = originalHeight + (targetHeight - originalHeight) * eased;

                        // apply styles
                        inventoryMini.style.left = Math.round(curLeft) + 'px';
                        inventoryMini.style.top = Math.round(curTop) + 'px';
                        inventoryMini.style.width = Math.round(curWidth) + 'px';
                        inventoryMini.style.height = Math.round(curHeight) + 'px';

                        // resize canvas pixel buffer and re-get context (resetting transforms)
                        canvas.width = Math.round(curWidth);
                        canvas.height = Math.round(curHeight);
                        miniGame.ctx = canvas.getContext('2d');

                        const ctx = miniGame.ctx;
                        ctx.clearRect(0,0,canvas.width,canvas.height);

                        // background wash
                        ctx.fillStyle = `rgba(10,10,10,${0.2 + eased * 0.8})`;
                        ctx.fillRect(0,0,canvas.width,canvas.height);

                        // chaotic colorful blocks
                        for(let i = 0; i < 12 + Math.floor(eased * 60); i++){
                            ctx.fillStyle = `hsla(${(i*37 + eased*360)%360},100%,${40 + Math.random()*30}%,${0.35 - eased*0.2})`;
                            ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 8 + Math.random()*80, 8 + Math.random()*80);
                        }

                        // expanding player aurora
                        ctx.fillStyle = '#ffff00';
                        const playerRadius = 12 + eased * Math.min(canvas.width, canvas.height) * 0.35;
                        ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, playerRadius, 0, Math.PI*2); ctx.fill();

                        // victory text
                        ctx.fillStyle = `rgba(255,255,255,${0.9*eased})`;
                        ctx.font = `bold ${24 + eased*56}px Arial`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText('üéâ VICTORY! üéâ', canvas.width/2, canvas.height/2 - (20 + eased*40));

                        if(t < 1){
                            miniGame.rafId = requestAnimationFrame(expand);
                        } else {
                            setTimeout(endMiniGame, 1800);
                        }
                    }

                    expand();
                }
                
                function endMiniGame(){
                    miniGame.active = false;
                    miniGame.expandMode = false;
                    if(miniGame.rafId) cancelAnimationFrame(miniGame.rafId);
                    if(miniGame.keyHandler) window.removeEventListener('keydown', miniGame.keyHandler);
                    
                    const inventoryMini = document.getElementById('inventory-mini');
                    if(inventoryMini){
                        inventoryMini.style.position = 'relative';
                        inventoryMini.style.top = 'auto';
                        inventoryMini.style.left = 'auto';
                        inventoryMini.style.width = '360px';
                        inventoryMini.style.height = '140px';
                        inventoryMini.style.zIndex = 'auto';
                        inventoryMini.style.borderRadius = '8px';
                    }
                    
                    const ctx = miniGame.ctx;
                    if(ctx && miniGame.canvas) ctx.clearRect(0, 0, miniGame.canvas.width, miniGame.canvas.height);
                    miniGame.canvas.width = 360;
                    miniGame.canvas.height = 140;
                    // re-acquire 2D context after resizing canvas
                    miniGame.ctx = miniGame.canvas.getContext('2d');
                    
                    miniGame.items = [];
                    miniGame.player = null;
                    document.getElementById('inventory-mini-score').textContent = 'Mini Score: 0';
                }

                // wire up play button (optional manual start)
                setTimeout(()=>{
                    const play = document.getElementById('inventory-play'); if(play) play.addEventListener('click', ()=>{ startMiniGame(); });
                }, 200);

            // particle overlay for escalating chaos
            const overlay = document.createElement('div');
            overlay.id = 'chaos-overlay';
            overlay.style.position = 'fixed'; overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.width = '100%'; overlay.style.height = '100%'; overlay.style.pointerEvents = 'none'; overlay.style.overflow = 'hidden'; overlay.style.zIndex = '9999';
            document.body.appendChild(overlay);

            // particles array
            const particles = [];

            function spawnParticle(intensity){
                const el = document.createElement('div');
                const size = 6 + Math.random()*30*intensity;
                el.style.position = 'absolute';
                el.style.left = Math.random()*100 + '%';
                el.style.top = Math.random()*100 + '%';
                el.style.width = size + 'px'; el.style.height = size + 'px';
                el.style.background = `hsl(${Math.random()*360}, 80%, ${40 + Math.random()*40}%)`;
                el.style.opacity = (0.05 + Math.random()*0.6).toString();
                el.style.borderRadius = (Math.random()>0.5? '50%':'2px');
                el.style.transform = `translate(-50%,-50%) rotate(${Math.random()*360}deg)`;
                const life = 800 + Math.random()*1600 / Math.max(1,intensity);
                overlay.appendChild(el);
                particles.push({el, life, age:0, vx:(Math.random()-0.5)*2*intensity, vy:(Math.random()-0.5)*2*intensity});
            }

            function animateParticles(dt){
                for(let i=particles.length-1;i>=0;i--){
                    const p = particles[i]; p.age += dt;
                    const x = parseFloat(p.el.style.left) + p.vx*dt*0.02;
                    const y = parseFloat(p.el.style.top) + p.vy*dt*0.02;
                    p.el.style.left = x + '%'; p.el.style.top = y + '%';
                    const lifeRatio = 1 - p.age / p.life;
                    p.el.style.opacity = Math.max(0, Number(p.el.style.opacity) * lifeRatio);
                    if(p.age > p.life){ p.el.remove(); particles.splice(i,1); }
                }
            }

            let last = performance.now();
            function raf(now){
                const dt = now - last; last = now;
                animateParticles(dt);
                requestAnimationFrame(raf);
            }
            requestAnimationFrame(raf);

            // helper: spawn a swarm of emoji icons into the overlay
            function spawnIconSwarm(icon, intensity, count){
                if(!overlay) return;
                const group = document.createElement('div');
                group.className = 'icon-swarm';
                group.style.position = 'absolute';
                group.style.left = '0'; group.style.top = '0'; group.style.width = '100%'; group.style.height = '100%';
                group.style.pointerEvents = 'none';
                overlay.appendChild(group);
                for(let i=0;i<count;i++){
                    const el = document.createElement('div');
                    el.textContent = icon;
                    const fs = Math.round((20 + Math.random()*60) + intensity*18);
                    el.style.position = 'absolute';
                    el.style.left = Math.random()*100 + '%';
                    el.style.top = Math.random()*100 + '%';
                    el.style.fontSize = fs + 'px';
                    el.style.opacity = (0.12 + Math.random()*0.7).toString();
                    el.style.transform = `translate(-50%,-50%) rotate(${Math.random()*360}deg)`;
                    el.style.transition = 'transform 1200ms linear, opacity 800ms linear';
                    group.appendChild(el);
                    // gentle float
                    setTimeout(()=>{
                        el.style.transform = `translate(${(Math.random()-0.5)*30}vw, ${(Math.random()-0.5)*30}vh) rotate(${Math.random()*720}deg) scale(${0.6 + Math.random()*1.2})`;
                        el.style.opacity = Math.max(0.08, Number(el.style.opacity) - 0.15);
                    }, 80 + Math.random()*400);
                }
                // remove after a while
                setTimeout(()=>{ try{ group.remove(); }catch(e){} }, 2200 + intensity*900);
            }

            // helper: spawn quick lightning bolt flashes
            function spawnLightningFlash(){
                if(!overlay) return;
                const bolt = document.createElement('div');
                bolt.className = 'lightning-bolt';
                const w = 6 + Math.random()*18;
                const h = 40 + Math.random()*60;
                bolt.style.position = 'absolute';
                bolt.style.left = Math.random()*100 + '%';
                bolt.style.top = Math.random()*60 + '%';
                bolt.style.width = w + 'px';
                bolt.style.height = h + 'vh';
                bolt.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.12))';
                bolt.style.boxShadow = '0 0 24px 8px rgba(255,255,255,0.6)';
                bolt.style.opacity = '0';
                bolt.style.transform = `rotate(${(Math.random()-0.5)*50}deg) translateY(-10vh)`;
                bolt.style.pointerEvents = 'none';
                overlay.appendChild(bolt);
                // flash in/out
                requestAnimationFrame(()=>{ bolt.style.transition = 'opacity 120ms linear, transform 400ms ease-out'; bolt.style.opacity = '0.98'; bolt.style.transform = bolt.style.transform.replace('-10vh','0vh'); });
                setTimeout(()=>{ bolt.style.opacity = '0'; }, 140 + Math.random()*260);
                setTimeout(()=>{ try{ bolt.remove(); }catch(e){} }, 700 + Math.random()*600);
                // also a quick whole-screen flash for dramatic effect (subtle)
                const flash = document.createElement('div');
                flash.style.position = 'fixed'; flash.style.left = '0'; flash.style.top = '0'; flash.style.width = '100%'; flash.style.height = '100%';
                flash.style.background = 'rgba(255,255,255,0.03)'; flash.style.pointerEvents = 'none'; flash.style.opacity = '0'; flash.style.zIndex = '99990';
                document.body.appendChild(flash);
                requestAnimationFrame(()=>{ flash.style.transition = 'opacity 80ms linear'; flash.style.opacity = '0.7'; });
                setTimeout(()=>{ flash.style.transition = 'opacity 220ms linear'; flash.style.opacity = '0'; }, 120);
                setTimeout(()=>{ try{ flash.remove(); }catch(e){} }, 400);
            }

            // small page-centered explosion effect (not covering games)
            function spawnPageExplosion(){
                if(!overlay) return;
                const ring = document.createElement('div');
                const x = Math.random()*60 + 20; // 20%..80% across
                const y = Math.random()*40 + 20; // 20%..60% down
                ring.style.position = 'absolute';
                ring.style.left = x + '%'; ring.style.top = y + '%';
                ring.style.width = '24px'; ring.style.height = '24px';
                ring.style.borderRadius = '50%';
                ring.style.border = '3px solid rgba(255,200,40,0.9)';
                ring.style.boxShadow = '0 0 18px 6px rgba(255,160,30,0.6)';
                ring.style.transform = 'translate(-50%,-50%) scale(0.6)';
                ring.style.opacity = '0.95';
                ring.style.pointerEvents = 'none';
                overlay.appendChild(ring);
                // burst small particles around the ring
                for(let i=0;i<14;i++){
                    const p = document.createElement('div');
                    p.style.position = 'absolute';
                    p.style.left = `calc(${x}% + ${Math.random()*120-60}px)`;
                    p.style.top = `calc(${y}% + ${Math.random()*80-40}px)`;
                    const s = 6 + Math.random()*22;
                    p.style.width = s + 'px'; p.style.height = s + 'px';
                    p.style.background = `hsl(${Math.random()*40+30},90%,${50+Math.random()*10}%)`;
                    p.style.borderRadius = '50%'; p.style.opacity = '0.95'; p.style.pointerEvents = 'none';
                    overlay.appendChild(p);
                    setTimeout(()=>{ try{ p.style.transition = 'transform 700ms ease-out, opacity 700ms'; p.style.transform = `translate(${(Math.random()-0.5)*40}vw, ${(Math.random()-0.5)*30}vh) scale(${0.3+Math.random()*1.4})`; p.style.opacity = '0'; }catch(e){} }, 20 + Math.random()*80);
                    setTimeout(()=>{ try{ p.remove(); }catch(e){} }, 900 + Math.random()*700);
                }
                // expand and fade ring
                requestAnimationFrame(()=>{ ring.style.transition = 'transform 700ms ease-out, opacity 700ms'; ring.style.transform = 'translate(-50%,-50%) scale(8)'; ring.style.opacity = '0'; });
                setTimeout(()=>{ try{ ring.remove(); }catch(e){} }, 820);
            }

            function calcGrand(){
                // product of all scores
                let prod = 1; let zero = false;
                Object.values(scores).forEach(v=>{ if(!v) zero = true; prod *= Math.max(0, v); });
                if(zero) prod = 0;
                return prod;
            }

            function resetChaos(){
                // remove all particles
                particles.forEach(p=>{ try{ p.el.remove(); }catch(e){} });
                particles.length = 0;
                // clear overlay
                overlay.innerHTML = '';
                // reset main (.wrap) styles so scoreboard stays unaffected
                if(main) main.style.filter = '';
                if(main) main.style.transform = '';
                body.style.background = presets[0];
                // reset game frames
                document.querySelectorAll('[id^="game-frame-wrapper"]').forEach(w=>{
                    w.style.animation = '';
                    w.style.transform = '';
                    w.querySelectorAll('iframe').forEach(iframe=>{ iframe.style.animation = ''; iframe.style.transform = ''; });
                });
                // notify frames to reset internal chaos state
                try{
                    const fb = document.getElementById('frame-bubble'); if(fb && fb.contentWindow) fb.contentWindow.postMessage({type:'reset'}, '*');
                    const fd = document.getElementById('frame-dodger'); if(fd && fd.contentWindow) fd.contentWindow.postMessage({type:'reset'}, '*');
                    const fc = document.getElementById('frame-color'); if(fc && fc.contentWindow) fc.contentWindow.postMessage({type:'reset'}, '*');
                }catch(e){}
            }

            function updateDisplay(){
                const grand = calcGrand();
                // Update chaos level indicator (no scores shown in nav)
                const chaosLevelEl = document.getElementById('chaos-level');
                if(!chaosLevelEl) return;
                if(grand === 0){
                    chaosLevelEl.textContent = 'CALM';
                    chaosLevelEl.style.background = 'rgba(0,255,0,0.2)';
                    chaosLevelEl.style.borderColor = '#00ff00';
                    chaosLevelEl.style.color = '#00ff00';
                } else if(grand < 10){
                    chaosLevelEl.textContent = 'üî• WARM';
                    chaosLevelEl.style.background = 'rgba(255,165,0,0.15)';
                    chaosLevelEl.style.borderColor = '#ffa500';
                    chaosLevelEl.style.color = '#ffa500';
                } else if(grand < 100){
                    chaosLevelEl.textContent = 'üî•üî• HOT';
                    chaosLevelEl.style.background = 'rgba(255,100,0,0.18)';
                    chaosLevelEl.style.borderColor = '#ff6400';
                    chaosLevelEl.style.color = '#ff6400';
                } else if(grand < 1000){
                    chaosLevelEl.textContent = 'üî•üî•üî• INFERNO';
                    chaosLevelEl.style.background = 'rgba(255,0,0,0.22)';
                    chaosLevelEl.style.borderColor = '#ff0000';
                    chaosLevelEl.style.color = '#ff0000';
                } else {
                    chaosLevelEl.textContent = 'üí• APOCALYPSE';
                    chaosLevelEl.style.background = 'rgba(255,0,255,0.3)';
                    chaosLevelEl.style.borderColor = '#ff00ff';
                    chaosLevelEl.style.color = '#ff00ff';
                    chaosLevelEl.style.animation = 'pulse 0.3s infinite';
                }
                
                escalateEffects(grand);
            }

            // intensity mapping: use log to temper explosion, clamp
            function escalateEffects(grand){
                if(!grand){
                    // when grand total is zero reset chaos
                    resetChaos();
                    document.getElementById('bacon').style.opacity = '0';
                    document.querySelectorAll('[id^="game-frame-wrapper"]').forEach(w=>{ w.style.transform = ''; w.querySelector('iframe').style.transform = ''; });
                    return;
                }

                const intensity = Math.min(12, Math.log10(grand + 1)); // 0..12 (extended for more levels)

                // background chaos: cycle presets randomly based on intensity
                if(Math.random() < Math.min(0.9, 0.05 + intensity*0.08)){
                    const idx = Math.floor(Math.random() * presets.length);
                    const noise = `linear-gradient(135deg, rgba(${~~(Math.random()*255)},${~~(Math.random()*255)},${~~(Math.random()*255)},${0.06 + Math.random()*0.25}), rgba(0,0,0,0.02))`;
                    body.style.background = presets[idx] + ',' + noise;
                }

                // visual filter intensity applied only to main (.wrap) so scoreboard is unaffected
                const hue = (performance.now() / 100) % 360;
                if(main) main.style.filter = `hue-rotate(${Math.round(hue * (0.2 + intensity*0.8))}deg) saturate(${1 + intensity*0.6}) blur(${Math.min(12, intensity*1.8)}px)`;

                    // spawn particles proportional to intensity
                const spawnCount = Math.ceil(1 + intensity*6);
                for(let i=0;i<spawnCount;i++) spawnParticle(1 + intensity*0.6);

                // random quick jitter transform (but not affecting scoreboard)
                if(Math.random() < Math.min(0.5, 0.02 + intensity*0.06)){
                    const sx = 1 + (Math.random()-0.5)*0.08*intensity;
                    const sy = 1 + (Math.random()-0.5)*0.08*intensity;
                    const rot = (Math.random()-0.5)*2*intensity;
                    if(main) main.style.transform = `scale(${sx},${sy}) rotate(${rot}deg)`;
                    setTimeout(()=> { if(main) main.style.transform = ''; }, 200 + intensity*120);
                }

                // HIGH CHAOS: Game disruptions start around intensity 4+
                const baconEl = document.getElementById('bacon');
                if(intensity >= 4){
                    // Bacon appears and blocks games
                    baconEl.style.opacity = Math.min(1, (intensity - 4) * 0.2);
                    baconEl.style.fontSize = (80 + (intensity - 4) * 20) + 'px';
                }

                // Game scaling/moving chaos at intensity 5+
                if(intensity >= 5){
                    const bubble = document.getElementById('game-frame-wrapper-bubble');
                    const dodger = document.getElementById('game-frame-wrapper-dodger');
                    const color = document.getElementById('game-frame-wrapper-color');
                    
                    // Random scale reduction
                    const scaleReduction = Math.max(0.6, 1 - (intensity - 5) * 0.08);
                    bubble.querySelector('iframe').style.transform = `scale(${scaleReduction})`;
                    dodger.querySelector('iframe').style.transform = `scale(${scaleReduction})`;
                    color.querySelector('iframe').style.transform = `scale(${scaleReduction})`;
                }

                // Game movement chaos at intensity 6+
                if(intensity >= 6){
                    const wrappers = ['bubble', 'dodger', 'color'];
                    const movements = ['driftLeft', 'driftRight', 'driftDown', 'driftUp'];
                    wrappers.forEach(name=>{
                        const wrapper = document.getElementById('game-frame-wrapper-' + name);
                        const move = movements[Math.floor(Math.random() * movements.length)];
                        wrapper.style.animation = `${move} ${2 - intensity*0.1}s infinite`;
                    });
                }

                // Ultra chaos at intensity 7+
                if(intensity >= 7){
                    document.getElementById('game-frame-wrapper-bubble').querySelector('iframe').style.animation = `shake ${0.4 - intensity*0.02}s infinite`;
                    document.getElementById('game-frame-wrapper-dodger').querySelector('iframe').style.animation = `shake ${0.4 - intensity*0.02}s infinite`;
                    document.getElementById('game-frame-wrapper-color').querySelector('iframe').style.animation = `shake ${0.4 - intensity*0.02}s infinite`;
                }

                // NEW: Additional chaos levels (8..12)
                // 8: mice swarm
                if(intensity >= 8){
                    if(Math.random() < 0.6) spawnIconSwarm('üê≠', intensity, Math.ceil(6 + intensity * 6));
                }

                // 9: bacon fills the screen with large icons
                if(intensity >= 9){
                    if(Math.random() < 0.7) spawnIconSwarm('ü•ì', intensity + 6, Math.ceil(4 + intensity * 4));
                }

                // 10: aggressively shrink all cards and iframes (extra compact)
                if(intensity >= 10){
                    document.querySelectorAll('.card').forEach(c=>{ c.style.transform = 'scale(0.62)'; c.style.transition = 'transform 180ms ease-out'; c.style.opacity = '0.98'; });
                    document.querySelectorAll('iframe').forEach(f=>{ f.style.transform = 'scale(0.62)'; f.style.transition = 'transform 180ms ease-out'; });
                }

                // 11: lightning flashes across the screen
                if(intensity >= 11){
                    // spawn multiple quick bolts randomly
                    if(Math.random() < 0.9) spawnLightningFlash();
                    if(Math.random() < 0.4) spawnLightningFlash();
                }

                // 12: full meltdown ‚Äî combine effects and increase density
                if(intensity >= 12){
                    // heavy overlay of mixed icons and frequent lightning
                    if(Math.random() < 0.95) spawnIconSwarm(['ü•ì','üê≠'][Math.floor(Math.random()*2)], intensity + 12, Math.ceil(10 + intensity*8));
                    if(Math.random() < 0.9) spawnLightningFlash();
                    // add a strong visual inversion occasionally
                    if(Math.random() < 0.3) main.style.filter += ' contrast(1.6) invert(0.08)';
                }

                // Send chaos message to iframes so games can speed up / invert controls
                try{
                    const speedMultiplier = 1 + intensity * 0.18; // games should speed up with intensity
                    const invertMouse = intensity >= 8; // invert mouse at high levels
                    const shrink = Math.max(0.6, 1 - (intensity - 5) * 0.06);
                    const msg = { type: 'chaos', intensity, speedMultiplier, invertMouse, shrink };
                    const fb = document.getElementById('frame-bubble'); if(fb && fb.contentWindow) fb.contentWindow.postMessage(msg, '*');
                    const fd = document.getElementById('frame-dodger'); if(fd && fd.contentWindow) fd.contentWindow.postMessage(msg, '*');
                    const fc = document.getElementById('frame-color'); if(fc && fc.contentWindow) fc.contentWindow.postMessage(msg, '*');
                }catch(e){}
            }

            // listen for messages from frames
            window.addEventListener('message', e=>{
                try{
                    const d = e.data;
                    if(d && d.type === 'score' && d.id){
                        if(d.id === 'bubble') scores.bubble = Number(d.score) || 0;
                        if(d.id === 'dodger') scores.dodger = Number(d.score) || 0;
                        if(d.id === 'color') scores.color = Number(d.score) || 0;
                        checkAndAwardItems();
                        updateDisplay();
                    }
                }catch(err){ }
            });

            // keydown background interaction still active but now tied to intensity
            document.addEventListener('keydown', function(e){
                const code = e.keyCode || e.which || 0;
                const idx = code % presets.length;
                const grand = calcGrand();
                const intensity = Math.min(8, Math.log10(grand + 1));
                const noise = `linear-gradient(135deg, rgba(${~~(Math.random()*255)},${~~(Math.random()*255)},${~~(Math.random()*255)},${0.06 + Math.random()*0.25*(1+intensity/3)}), rgba(0,0,0,0.02))`;
                body.style.background = presets[idx] + ',' + noise;
                if(main) main.style.filter = `hue-rotate(${(code % 360) * (0.2 + intensity*0.8)}deg) saturate(${1 + intensity*0.6})`;
            });

            // small reset interval to slowly increase chaos over time if grand grows
            setInterval(()=>{ updateDisplay(); }, 1400);
            
            // Initialize inventory display on load
            updateInventoryDisplay();
        })();
    </script>
</body>
</html>
