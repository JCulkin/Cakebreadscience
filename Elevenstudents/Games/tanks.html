<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tanks Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            text-align: center;
        }

        canvas {
            border: 4px solid #fff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #2d5016;
            display: block;
            margin: 0 auto;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .start-content {
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 30px 50px;
            border-radius: 20px;
            border: 2px solid rgba(0, 255, 0, 0.5);
        }

        .start-content h1 {
            font-size: 56px;
            margin-bottom: 5px;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            color: #00ff00;
        }

        .start-content .subtitle {
            font-size: 18px;
            margin-bottom: 25px;
            opacity: 0.8;
        }

        .instructions {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 30px;
            border-radius: 12px;
            margin-top: 15px;
            text-align: left;
            display: inline-block;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #00ffff;
            font-size: 16px;
        }

        .instructions p {
            margin: 5px 0;
            font-size: 14px;
        }

        .instructions span {
            color: #ffff00;
            font-weight: bold;
            font-size: 20px;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .mode-btn {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        .mode-btn.normal {
            background: linear-gradient(180deg, #4CAF50 0%, #2E7D32 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .mode-btn.hardcore {
            background: linear-gradient(180deg, #f44336 0%, #b71c1c 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4);
        }

        .mode-btn:hover {
            transform: scale(1.05);
        }

        .mode-btn.normal:hover {
            box-shadow: 0 8px 30px rgba(76, 175, 80, 0.6);
        }

        .mode-btn.hardcore:hover {
            box-shadow: 0 8px 30px rgba(244, 67, 54, 0.6);
        }

        .mode-description {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }

        #levelIntro {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .level-intro-content {
            text-align: center;
            color: white;
        }

        .level-intro-content h1 {
            font-size: 72px;
            margin-bottom: 10px;
            text-shadow: 0 0 30px currentColor;
        }

        .level-intro-content .theme-name {
            font-size: 32px;
            text-transform: uppercase;
            letter-spacing: 5px;
            opacity: 0.8;
        }

        .level-intro-content.hardcore h1 {
            color: #ff4444;
        }

        .level-intro-content.normal h1 {
            color: #00ffff;
        }

        .mode-btn.test {
            background: linear-gradient(180deg, #9c27b0 0%, #6a1b9a 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
        }

        .mode-btn.test:hover {
            box-shadow: 0 8px 30px rgba(156, 39, 176, 0.6);
        }

        #levelSelectScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .level-select-content {
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 30px 50px;
            border-radius: 20px;
            border: 2px solid rgba(156, 39, 176, 0.5);
        }

        .level-select-content h1 {
            font-size: 42px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #9c27b0, 0 0 40px #9c27b0;
            color: #ce93d8;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .level-btn {
            width: 80px;
            height: 80px;
            font-size: 24px;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .level-btn:hover {
            transform: scale(1.1);
        }

        .level-btn .level-num {
            font-size: 28px;
        }

        .level-btn .level-theme {
            font-size: 10px;
            opacity: 0.8;
            text-transform: uppercase;
        }

        .back-btn {
            padding: 12px 30px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .mode-btn.multiplayer {
            background: linear-gradient(180deg, #2196F3 0%, #1565C0 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        .mode-btn.multiplayer:hover {
            box-shadow: 0 8px 30px rgba(33, 150, 243, 0.6);
        }

        #multiplayerScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .multiplayer-content {
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 30px 50px;
            border-radius: 20px;
            border: 2px solid rgba(33, 150, 243, 0.5);
        }

        .multiplayer-content h1 {
            font-size: 42px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #2196F3, 0 0 40px #2196F3;
            color: #64b5f6;
        }

        .mp-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mp-btn {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            background: linear-gradient(180deg, #4CAF50 0%, #2E7D32 100%);
            color: white;
        }

        .mp-btn:hover {
            transform: scale(1.05);
        }

        .mp-btn.join {
            background: linear-gradient(180deg, #ff9800 0%, #e65100 100%);
        }

        .room-input {
            padding: 12px 20px;
            font-size: 24px;
            text-align: center;
            border: 3px solid #2196F3;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            width: 200px;
            margin: 10px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        .room-code-display {
            font-size: 48px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            letter-spacing: 10px;
            margin: 20px 0;
        }

        .waiting-text {
            font-size: 18px;
            color: #ffff00;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .player2-indicator {
            position: absolute;
            top: 10px;
            right: 120px;
            background: rgba(0, 100, 255, 0.7);
            padding: 5px 15px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            display: none;
        }

        /* Battle Royale Lobby Styles */
        .br-lobby {
            max-width: 600px;
            margin: 0 auto;
        }

        .br-setup {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .br-setup input {
            padding: 12px 20px;
            font-size: 18px;
            border: 2px solid #f44336;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            width: 200px;
            text-align: center;
        }

        .br-setup input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .tank-selection {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .tank-option {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            transition: all 0.2s;
        }

        .tank-option:hover {
            border-color: #f44336;
            transform: scale(1.1);
        }

        .tank-option.selected {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.3);
            box-shadow: 0 0 20px rgba(244, 67, 54, 0.5);
        }

        .player-list {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .player-list h3 {
            margin: 0 0 10px 0;
            color: #f44336;
            font-size: 16px;
        }

        .player-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin: 5px 0;
        }

        .player-entry .tank-icon {
            font-size: 24px;
        }

        .player-entry .player-name {
            flex: 1;
            text-align: left;
            font-weight: bold;
        }

        .player-entry .player-badges {
            display: flex;
            gap: 2px;
        }

        .player-entry.host {
            border: 2px solid #ffd700;
        }

        .host-badge {
            background: #ffd700;
            color: black;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }

        .win-badge {
            font-size: 14px;
        }

        .begin-btn {
            padding: 15px 50px;
            font-size: 24px;
            background: linear-gradient(180deg, #f44336 0%, #b71c1c 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 10px;
        }

        .begin-btn:hover {
            transform: scale(1.05);
        }

        .begin-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .winner-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .winner-content {
            text-align: center;
            color: white;
        }

        .winner-content h1 {
            font-size: 64px;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            margin-bottom: 20px;
        }

        .winner-content .winner-name {
            font-size: 48px;
            color: #ff6659;
            margin-bottom: 30px;
        }

        .winner-content .winner-tank {
            font-size: 100px;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="player2-indicator" id="player2Indicator">P2 CONNECTED</div>
    </div>

    <div id="multiplayerScreen">
        <div class="multiplayer-content" id="mpContent">
            <h1>üåê MULTIPLAYER</h1>
            <div id="mpLobby">
                <p style="margin-bottom: 15px;">Choose a mode:</p>
                <p id="mpPlayerCount" style="font-size: 16px; color: #64b5f6; margin-bottom: 20px;">Checking players online...</p>
                <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                    <div style="text-align: center;">
                        <button class="mp-btn" onclick="joinMultiplayer('coop')" style="font-size: 20px; padding: 20px 40px; background: linear-gradient(180deg, #4CAF50 0%, #2E7D32 100%);">ü§ù CO-OP</button>
                        <p style="font-size: 12px; opacity: 0.8; margin-top: 8px;">Team up vs enemies</p>
                    </div>
                    <div style="text-align: center;">
                        <button class="mp-btn" onclick="showBattleRoyaleLobby()" style="font-size: 20px; padding: 20px 40px; background: linear-gradient(180deg, #f44336 0%, #b71c1c 100%);">‚öîÔ∏è BATTLE</button>
                        <p style="font-size: 12px; opacity: 0.8; margin-top: 8px;">Fight other players</p>
                    </div>
                </div>
            </div>
            
            <!-- Battle Royale Lobby -->
            <div id="brLobby" class="br-lobby" style="display: none;">
                <h2 style="color: #f44336; margin-bottom: 15px;">‚öîÔ∏è BATTLE ROYALE</h2>
                
                <div id="brJoinOrHost">
                    <div class="br-setup">
                        <input type="text" id="brPlayerName" placeholder="Your Name" maxlength="12">
                    </div>
                    <p style="font-size: 14px; margin-bottom: 5px;">Choose your icon:</p>
                    <div class="tank-selection" id="iconSelection">
                        <div class="tank-option selected" data-icon="üéñÔ∏è" onclick="selectIcon(this)">üéñÔ∏è</div>
                        <div class="tank-option" data-icon="üèéÔ∏è" onclick="selectIcon(this)">üèéÔ∏è</div>
                        <div class="tank-option" data-icon="üöÄ" onclick="selectIcon(this)">üöÄ</div>
                        <div class="tank-option" data-icon="üíÄ" onclick="selectIcon(this)">üíÄ</div>
                        <div class="tank-option" data-icon="üî•" onclick="selectIcon(this)">üî•</div>
                        <div class="tank-option" data-icon="‚ö°" onclick="selectIcon(this)">‚ö°</div>
                        <div class="tank-option" data-icon="üåü" onclick="selectIcon(this)">üåü</div>
                        <div class="tank-option" data-icon="üéØ" onclick="selectIcon(this)">üéØ</div>
                    </div>
                    <p style="font-size: 14px; margin: 10px 0 5px 0;">Choose your shape:</p>
                    <div class="tank-selection" id="shapeSelection">
                        <div class="tank-option selected" data-shape="triangle" onclick="selectShape(this)">‚ñ≤</div>
                        <div class="tank-option" data-shape="square" onclick="selectShape(this)">‚ñ†</div>
                        <div class="tank-option" data-shape="pentagon" onclick="selectShape(this)">‚¨ü</div>
                        <div class="tank-option" data-shape="hexagon" onclick="selectShape(this)">‚¨¢</div>
                        <div class="tank-option" data-shape="circle" onclick="selectShape(this)">‚óè</div>
                        <div class="tank-option" data-shape="diamond" onclick="selectShape(this)">‚óÜ</div>
                    </div>
                    <p style="font-size: 16px; margin: 20px 0 10px 0; font-weight: bold; color: #64b5f6;">Select a Lobby:</p>
                    <div style="display: grid; gap: 15px; margin-top: 10px;">
                        <button class="mp-btn" onclick="joinBattleLobby(1)" style="background: linear-gradient(180deg, #4CAF50 0%, #2E7D32 100%); position: relative;">
                            <span style="font-size: 20px;">üéÆ Lobby 1</span>
                            <span id="lobby1Count" style="display: block; font-size: 14px; opacity: 0.9; margin-top: 5px;">0 players</span>
                        </button>
                        <button class="mp-btn" onclick="joinBattleLobby(2)" style="background: linear-gradient(180deg, #ff9800 0%, #e65100 100%); position: relative;">
                            <span style="font-size: 20px;">üéÆ Lobby 2</span>
                            <span id="lobby2Count" style="display: block; font-size: 14px; opacity: 0.9; margin-top: 5px;">0 players</span>
                        </button>
                        <button class="mp-btn" onclick="joinBattleLobby(3)" style="background: linear-gradient(180deg, #9c27b0 0%, #6a1b9a 100%); position: relative;">
                            <span style="font-size: 20px;">üéÆ Lobby 3</span>
                            <span id="lobby3Count" style="display: block; font-size: 14px; opacity: 0.9; margin-top: 5px;">0 players</span>
                        </button>
                    </div>
                </div>
                
                <div id="brWaitingRoom" style="display: none;">
                    <h3 id="currentLobbyTitle" style="color: #64b5f6; margin-bottom: 10px;">üéÆ Lobby 1</h3>
                    <p style="font-size: 14px; color: #ff6659; margin-bottom: 10px;">‚ù§Ô∏è‚ù§Ô∏è Everyone gets 2 lives!</p>
                    <div class="player-list" id="brPlayerList">
                        <h3>üë• PLAYERS IN LOBBY</h3>
                        <div id="brPlayersContainer"></div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="begin-btn" id="brBeginBtn" onclick="startBattleRoyale()" disabled>‚öîÔ∏è BEGIN BATTLE!</button>
                        <p style="font-size: 12px; opacity: 0.7; margin-top: 5px;">Need at least 2 players to start</p>
                        <p style="font-size: 12px; opacity: 0.7; margin-top: 8px;">Game starts automatically when 2+ players ready</p>
                    </div>
                </div>
            </div>
            
            <div id="mpConnecting" style="display: none;">
                <p class="waiting-text">Connecting to game...</p>
            </div>
            <br>
            <button class="back-btn" onclick="hideMultiplayer()">‚Üê Back to Menu</button>
        </div>
    </div>
    
    <!-- End Screen (shows for all players) -->
    <div id="endScreen" class="winner-screen">
        <div class="winner-content">
            <h1 id="endTitle">üèÜ GAME OVER üèÜ</h1>
            <div id="endWinnerSection" style="display: none;">
                <div class="winner-tank" id="winnerTank">üéñÔ∏è</div>
                <div class="winner-name" id="winnerName">Player</div>
                <p style="font-size: 24px; color: #ffd700; margin-bottom: 20px;">+1 üèÖ Winner Badge!</p>
            </div>
            <div id="endLoserSection" style="display: none;">
                <p style="font-size: 24px; color: #ff6659; margin-bottom: 10px;">üí• You were eliminated!</p>
                <p style="font-size: 20px; color: #ffd700; margin-bottom: 20px;">üèÜ Winner: <span id="eliminatedWinner">Player</span></p>
            </div>
            <div style="background: rgba(0,0,0,0.5); border-radius: 10px; padding: 15px; margin: 20px 0; max-width: 300px; margin-left: auto; margin-right: auto;">
                <h3 style="color: #64b5f6; margin: 0 0 10px 0;">üéØ HITS LEADERBOARD</h3>
                <div id="hitsLeaderboard" style="text-align: left;"></div>
            </div>
            <button class="begin-btn" onclick="returnToLobby()">üîÑ Return to Lobby</button>
        </div>
    </div>

    <div id="startScreen">
        <div class="start-content">
            <h1>üéÆ TANKS BATTLE</h1>
            <p class="subtitle">Destroy all enemies to advance through levels!</p>
            <div class="mode-buttons">
                <div>
                    <button class="mode-btn normal" onclick="beginGame('normal')">NORMAL MODE</button>
                </div>
                <div>
                    <button class="mode-btn multiplayer" onclick="showMultiplayer()">üåê MULTIPLAYER</button>
                </div>
                <div>
                    <button class="mode-btn test" onclick="showLevelSelect()">üß™ TEST</button>
                </div>
                <div>
                    <button class="mode-btn hardcore" onclick="beginGame('hardcore')">üíÄ HARDCORE</button>
                    <div class="mode-description">Instant death ‚Ä¢ 3x speed</div>
                </div>
            </div>
            <div class="instructions">
                <h3>How to Play:</h3>
                <p><span>‚å®Ô∏è W A S D</span> - Move your tank</p>
                <p><span>üñ±Ô∏è Mouse</span> - Aim your turret</p>
                <p><span>üñ±Ô∏è Click or ‚éµ SPACE</span> - Fire!</p>
                <p><span>‚èé ENTER</span> - Pause game</p>
            </div>
        </div>
    </div>

    <div id="levelIntro">
        <div class="level-intro-content" id="levelIntroContent">
            <h1>LEVEL <span id="levelIntroNumber">1</span></h1>
            <div class="theme-name" id="levelIntroTheme">FOREST</div>
        </div>
    </div>

    <div id="levelSelectScreen">
        <div class="level-select-content">
            <h1>üß™ TEST MODE - Select Level</h1>
            <div class="level-grid" id="levelGrid"></div>
            <button class="back-btn" onclick="hideLevelSelect()">‚Üê Back to Menu</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // CONFIGURATION & CONSTANTS
        // ============================================
        const MAP_WIDTH = 1500;
        const MAP_HEIGHT = 1500;

        let enemiesPerLevel = [5, 8, 10, 12, 15, 18, 20, 25, 12];
        const MAX_LEVEL = 9;

        let currentTheme = 'jungle';
        const themes = ['jungle', 'town', 'desert', 'beach', 'snow', 'volcano', 'airport', 'moon', 'space'];
        const levelNames = ['THE JUNGLE', 'THE TOWN', 'THE DESERT', 'THE BEACH', 'THE ARCTIC', 'THE VOLCANO', 'THE AIRPORT', 'THE MOON', 'DEEP SPACE'];

        const themeColors = {
            town: { ground: '#5a5a5a', building: '#8B7355', tree: '#228B22', water: '#4169E1', raised: '#4a4a4a' },
            jungle: { ground: '#7CCD7C', building: '#8b4513', tree: '#006400', water: '#20b2aa', raised: '#2d5016' },
            desert: { ground: '#e6c88a', building: '#c2956e', tree: '#9acd32', water: '#87ceeb', raised: '#d4a574' },
            beach: { ground: '#f5deb3', building: '#deb887', tree: '#32cd32', water: '#00ced1', raised: '#d2b48c' },
            snow: { ground: '#e8f4f8', building: '#708090', tree: '#2f4f4f', water: '#b0e0e6', raised: '#c0d6df' },
            volcano: { ground: '#3d2817', building: '#8b0000', tree: '#4a4a4a', water: '#ff4500', raised: '#5c3d2e' },
            airport: { ground: '#4a4a4a', building: '#c0c0c0', tree: '#228B22', water: '#4169E1', raised: '#606060' },
            moon: { ground: '#a0a0a0', building: '#808080', tree: '#606060', water: '#2a2a4a', raised: '#b0b0b0' },
            space: { ground: '#0a0a20', building: '#4a4a6a', tree: '#2a2a4a', water: '#1a1a3a', raised: '#3a3a5a' }
        };

        // Special level entities
        const animals = [];
        const planes = [];
        const astronauts = [];
        const movingWater = [];
        const dustParticles = [];
        const icePatches = [];
        const fireParticles = [];
        const meteors = [];
        const bossStatues = [];
        const conveyorBelts = [];
        let levelSpeedMultiplier = 1;
        let lavaExpansionTimer = 0;
        let lavaExpansionRate = 2; // pixels per second - expands outward from center!
        
        // Player velocity for space/ice/moon physics
        let playerVelX = 0;
        let playerVelY = 0;
        let onIce = false;
        let moonBounceVel = 0; // For moon bouncing
        let moonBounceTimer = 0;

        const camera = { x: 0, y: 0 };

        const player = {
            x: MAP_WIDTH / 2,
            y: MAP_HEIGHT / 2,
            width: 40,
            height: 40,
            angle: 0,
            speed: 5,
            health: 100,
            maxHealth: 100,
            color: '#00ff00',
            isHovercraft: false,
            elevated: false,
            shootCooldown: 500,
            baseShootCooldown: 500,
            shieldActive: false,
            damageBoost: false,
            ghost: false,
            multishot: false,
            // Permanent upgrades
            armorLevel: 0,
            bulletSpeedBonus: 0,
            magnetRange: 0,
            regenRate: 0
        };

        const bullets = [];
        const enemyBullets = [];
        const enemies = [];
        const allies = []; // Friendly tanks!
        let boss = null;
        const obstacles = [];
        const upgrades = [];
        const powerups = [];
        
        // Track permanent powerups for UI display
        const permanentPowerups = [];

        const keys = {};
        let mouseX = 0;
        let mouseY = 0;

        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let currentLevel = 1;
        let lastShotTime = 0;
        let demoMode = true;
        let gameMode = 'normal';
        let showingLevelIntro = false;
        let levelIntroTimer = 0;
        let levelTransitionCountdown = 0;
        let levelTransitionActive = false;

        let activePowerups = [];
        let powerupPopup = { text: '', timer: 0 };
        
        // ============================================
        // MULTIPLAYER CONFIGURATION
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyARP2uokd2lPxXcpPwII3MfK6b_NzSmeO8",
            authDomain: "elevenstudents-76f31.firebaseapp.com",
            databaseURL: "https://elevenstudents-76f31-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "elevenstudents-76f31",
            storageBucket: "elevenstudents-76f31.firebasestorage.app",
            messagingSenderId: "692298982954",
            appId: "1:692298982954:web:faa16da6abfcb5eef8c553"
        };
        
        // Initialize Firebase (will fail gracefully if config is invalid)
        let firebaseApp = null;
        let database = null;
        let roomRef = null;
        
        try {
            firebaseApp = firebase.initializeApp(firebaseConfig);
            database = firebase.database();
        } catch (e) {
            console.log('Firebase not configured - multiplayer disabled');
        }
        
        // Multiplayer state
        let isMultiplayer = false;
        let isHost = false;
        let roomCode = '';
        let battleKills = 0;
        let player2 = {
            x: 0,
            y: 0,
            angle: 0,
            health: 100,
            connected: false,
            color: '#0088ff'
        };
        let syncInterval = null;
        
        // Battle Royale lobby state
        let brPlayerName = '';
        let brSelectedIcon = 'üéñÔ∏è';
        let brSelectedShape = 'triangle';
        let brLobbyRef = null;
        let brGameRef = null;
        let brWins = 0; // Session only, resets on page reload
        let brLobbyPlayers = {};
        let brInitialPlayerCount = 0; // Store player count when game starts
        let brGameStartTime = 0;
        let brCurrentLobby = 1; // Which lobby (1, 2, or 3) the player is in
        let battleLives = 2;
        let battleHits = 0;
        let battleLeaderboard = {};
        let isEliminated = false; // Ghost mode when eliminated
        let lobbyCountRefs = []; // References for listening to lobby counts

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function checkCollision(rect1, obstacle) {
            return rect1.x < obstacle.x + obstacle.width &&
                   rect1.x + rect1.width > obstacle.x &&
                   rect1.y < obstacle.y + obstacle.height &&
                   rect1.y + rect1.height > obstacle.y;
        }

        function isFullyOnElevated(playerRect, obstacles) {
            const elevated = obstacles.filter(o => o.type === 'raised' || o.type === 'ramp');
            const corners = [
                { x: playerRect.x, y: playerRect.y },
                { x: playerRect.x + playerRect.width, y: playerRect.y },
                { x: playerRect.x, y: playerRect.y + playerRect.height },
                { x: playerRect.x + playerRect.width, y: playerRect.y + playerRect.height }
            ];
            for (let corner of corners) {
                let cornerOnElevated = false;
                for (let obs of elevated) {
                    if (corner.x >= obs.x && corner.x <= obs.x + obs.width &&
                        corner.y >= obs.y && corner.y <= obs.y + obs.height) {
                        cornerOnElevated = true;
                        break;
                    }
                }
                if (!cornerOnElevated) return false;
            }
            return true;
        }

        function checkBulletCollision(bullet, target) {
            const dx = bullet.x - target.x;
            const dy = bullet.y - target.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < bullet.radius + target.width / 2;
        }

        function updateCamera() {
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            camera.x = Math.max(0, Math.min(MAP_WIDTH - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(MAP_HEIGHT - canvas.height, camera.y));
        }

        function updateUI() {}

        function drawUI() {
            const boxWidth = 120;
            const boxHeight = 50;
            const boxY = 10;
            const boxPadding = 15;
            const startX = 10;
            
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // In battle mode, show LIVES instead of LEVEL
            if (isMultiplayer && multiplayerMode === 'battle') {
                const livesText = '‚ù§Ô∏è'.repeat(battleLives);
                drawStatBox(startX, boxY, boxWidth, boxHeight, 'LIVES', livesText || 'üíÄ', '#f44336');
            } else {
                drawStatBox(startX, boxY, boxWidth, boxHeight, 'LEVEL', currentLevel, '#4CAF50');
            }
            
            const healthColor = player.health > 50 ? '#4CAF50' : (player.health > 25 ? '#ff9800' : '#f44336');
            drawStatBox(startX + boxWidth + boxPadding, boxY, boxWidth, boxHeight, 'HEALTH', Math.max(0, player.health), healthColor);
            
            // Hide score and enemies in battle royale mode
            if (!(isMultiplayer && multiplayerMode === 'battle')) {
                drawStatBox(startX + (boxWidth + boxPadding) * 2, boxY, boxWidth, boxHeight, 'SCORE', score, '#2196F3');
                
                const enemyText = enemies.length + (boss ? ' +BOSS' : '');
                drawStatBox(startX + (boxWidth + boxPadding) * 3, boxY, boxWidth + 20, boxHeight, 'ENEMIES', enemyText, '#f44336');
            } else {
                // Show kills and players in battle mode
                drawStatBox(startX + (boxWidth + boxPadding) * 2, boxY, boxWidth, boxHeight, 'KILLS', battleKills || 0, '#f44336');
                drawStatBox(startX + (boxWidth + boxPadding) * 3, boxY, boxWidth + 20, boxHeight, 'PLAYERS', Object.keys(otherPlayers).length + 1, '#9c27b0');
            }
            
            if (gameMode === 'hardcore') {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(canvas.width - 110, boxY, 100, boxHeight);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - 110, boxY, 100, boxHeight);
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('üíÄ HARDCORE', canvas.width - 60, boxY + boxHeight / 2);
            }
            
            if (powerupPopup.timer > 0) {
                const popupAlpha = Math.min(1, powerupPopup.timer / 30);
                const popupWidth = Math.min(powerupPopup.text.length * 10 + 40, 350);
                ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * popupAlpha})`;
                ctx.fillRect(canvas.width / 2 - popupWidth / 2, 80, popupWidth, 40);
                ctx.strokeStyle = `rgba(255, 255, 0, ${popupAlpha})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width / 2 - popupWidth / 2, 80, popupWidth, 40);
                ctx.fillStyle = `rgba(255, 255, 0, ${popupAlpha})`;
                ctx.font = 'bold 14px Arial';
                ctx.fillText(powerupPopup.text, canvas.width / 2, 100);
                powerupPopup.timer--;
            }
            
            if (activePowerups.length > 0) {
                const barY = canvas.height - 40;
                let xOffset = 10;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                activePowerups.forEach((powerup) => {
                    const timeLeft = Math.ceil(powerup.timeLeft / 60);
                    const barWidth = 130;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(xOffset, barY, barWidth, 30);
                    ctx.strokeStyle = powerup.color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(xOffset, barY, barWidth, 30);
                    ctx.fillStyle = powerup.color;
                    ctx.fillText(`${powerup.icon} ${powerup.name}: ${timeLeft}s`, xOffset + 8, barY + 18);
                    xOffset += barWidth + 10;
                });
            }
            
            // Draw PERMANENT powerups at bottom of screen (above active powerups)
            if (permanentPowerups.length > 0) {
                const permY = canvas.height - 80;
                let xOffset = 10;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                
                // Label
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(xOffset, permY, 90, 25);
                ctx.fillStyle = '#ffd700';
                ctx.fillText('PERMANENT:', xOffset + 5, permY + 16);
                xOffset += 95;
                
                permanentPowerups.forEach((powerup) => {
                    const boxWidth = powerup.count > 1 ? 80 : 65;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(xOffset, permY, boxWidth, 25);
                    ctx.strokeStyle = powerup.color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(xOffset, permY, boxWidth, 25);
                    ctx.fillStyle = powerup.color;
                    const countText = powerup.count > 1 ? ` x${powerup.count}` : '';
                    ctx.fillText(`${powerup.icon} ${powerup.name}${countText}`, xOffset + 5, permY + 16);
                    xOffset += boxWidth + 5;
                });
            }
            
            // Show allies count if any
            if (allies.length > 0) {
                ctx.fillStyle = 'rgba(0, 100, 0, 0.7)';
                ctx.fillRect(canvas.width - 110, canvas.height - 40, 100, 30);
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width - 110, canvas.height - 40, 100, 30);
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`üõ°Ô∏è ALLIES: ${allies.length}`, canvas.width - 60, canvas.height - 22);
            }
        }

        function drawStatBox(x, y, width, height, label, value, color) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x + width / 2, y + 12);
            ctx.fillStyle = color;
            ctx.font = 'bold 18px Arial';
            ctx.fillText(value, x + width / 2, y + 34);
        }

        function showPowerupPopup(text) {
            powerupPopup.text = text;
            powerupPopup.timer = 90;
        }

        function addActivePowerup(name, icon, color, duration) {
            activePowerups = activePowerups.filter(p => p.name !== name);
            activePowerups.push({ name, icon, color, timeLeft: duration });
        }
        
        function addPermanentPowerup(name, icon, color) {
            // Stack same types by counting
            const existing = permanentPowerups.find(p => p.name === name && !p.name.includes('ARM') && !p.name.includes('ALLY'));
            if (existing && !name.includes('ARM')) {
                existing.count = (existing.count || 1) + 1;
            } else {
                permanentPowerups.push({ name, icon, color, count: 1 });
            }
        }

        function updateActivePowerups() {
            activePowerups = activePowerups.filter(p => {
                p.timeLeft--;
                return p.timeLeft > 0;
            });
        }

        // ============================================
        // CLASSES
        // ============================================
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 20;
                this.height = 20;
                this.lifetime = 15000;
                this.spawnTime = Date.now();
            }

            draw() {
                const colors = { 
                    rapidfire: '#ff6600', 
                    health: '#00ff00', 
                    speed: '#00ffff',
                    shield: '#0066ff',
                    damage: '#ff00ff',
                    ghost: '#aaaaaa',
                    multishot: '#ffff00',
                    // Permanent powerups (gold border)
                    maxhealth: '#ff69b4',
                    armor: '#b8860b',
                    bulletspeed: '#ff4444',
                    magnet: '#9932cc',
                    regen: '#32cd32',
                    ally: '#00ff00'
                };
                const symbols = { 
                    rapidfire: '‚ö°', 
                    health: '+', 
                    speed: '‚Üë',
                    shield: 'üõ°',
                    damage: 'üí•',
                    ghost: 'üëª',
                    multishot: '‚ú¶',
                    maxhealth: '‚ô•',
                    armor: 'üî∞',
                    bulletspeed: '¬ª',
                    magnet: 'üß≤',
                    regen: '‚ôª',
                    ally: 'üü¢'
                };
                const labels = {
                    rapidfire: 'RAPID',
                    health: 'HEAL',
                    speed: 'SPEED',
                    shield: 'SHIELD',
                    damage: 'DMG',
                    ghost: 'GHOST',
                    multishot: 'MULTI',
                    maxhealth: '+HP',
                    armor: 'ARMOR',
                    bulletspeed: 'B.SPD',
                    magnet: 'MAG',
                    regen: 'REGEN',
                    ally: 'ALLY'
                };
                const isPermanent = ['maxhealth', 'armor', 'bulletspeed', 'regen', 'ally'].includes(this.type);
                ctx.fillStyle = colors[this.type];
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.width / 2 + 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Gold border for permanent powerups, white for temporary
                ctx.strokeStyle = isPermanent ? '#ffd700' : '#ffffff';
                ctx.lineWidth = isPermanent ? 4 : 2;
                ctx.stroke();
                
                // Extra sparkle for permanent powerups
                if (isPermanent) {
                    const sparkle = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 215, 0, ${sparkle})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x - camera.x, this.y - camera.y, this.width / 2 + 7, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbols[this.type], this.x - camera.x, this.y - camera.y);
                
                // Label below powerup
                ctx.fillStyle = isPermanent ? '#ffd700' : colors[this.type];
                ctx.font = 'bold 8px Arial';
                ctx.fillText(labels[this.type], this.x - camera.x, this.y - camera.y + 17);
                if (isPermanent) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 6px Arial';
                    ctx.fillText('PERM', this.x - camera.x, this.y - camera.y + 24);
                }
            }
            
            isExpired() {
                return Date.now() - this.spawnTime > this.lifetime;
            }
        }

        class Upgrade {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 25;
                this.height = 25;
                this.collected = false;
            }

            draw() {
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(this.x - camera.x - this.width / 2, this.y - camera.y - this.height / 2, this.width, this.height);
                ctx.strokeStyle = '#FFA500';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - camera.x - this.width / 2, this.y - camera.y - this.height / 2, this.width, this.height);
                ctx.fillStyle = '#FFA500';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚òÖ', this.x - camera.x, this.y - camera.y);
            }
        }

        class Obstacle {
            constructor(x, y, width, height, type, rampDir = 'right') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.rampDir = rampDir;
                this.burned = false;
                this.variant = Math.floor(Math.random() * 3);
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                const colors = themeColors[currentTheme];
                
                if (this.type === 'building') {
                    ctx.fillStyle = this.burned ? '#3d3d3d' : colors.building;
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.strokeStyle = this.burned ? '#1a1a1a' : '#654321';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, this.width, this.height);
                    
                    if (this.burned) {
                        // Burned building - broken windows, smoke marks
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(screenX + 5, screenY + 5, 20, 25);
                        ctx.fillRect(screenX + this.width - 25, screenY + 10, 15, 20);
                        // Smoke marks
                        ctx.fillStyle = '#2a2a2a';
                        ctx.beginPath();
                        ctx.arc(screenX + this.width/2, screenY - 10, 15, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Normal windows
                        ctx.fillStyle = currentTheme === 'moon' ? '#4a6a8a' : '#FFD700';
                        const windowSize = Math.min(15, this.width / 4);
                        for (let i = 0; i < 2; i++) {
                            for (let j = 0; j < 2; j++) {
                                if (screenX + 8 + i * (this.width/2) + windowSize < screenX + this.width &&
                                    screenY + 8 + j * (this.height/2) + windowSize < screenY + this.height) {
                                    ctx.fillRect(screenX + 8 + i * (this.width/2 - 5), screenY + 8 + j * (this.height/2 - 5), windowSize, windowSize);
                                }
                            }
                        }
                    }
                } else if (this.type === 'wooden_building') {
                    // Wooden jungle building
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    // Wood planks
                    ctx.strokeStyle = '#5c3317';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < this.height; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY + i);
                        ctx.lineTo(screenX + this.width, screenY + i);
                        ctx.stroke();
                    }
                    // Straw roof
                    ctx.fillStyle = '#d2b48c';
                    ctx.beginPath();
                    ctx.moveTo(screenX - 5, screenY);
                    ctx.lineTo(screenX + this.width / 2, screenY - 20);
                    ctx.lineTo(screenX + this.width + 5, screenY);
                    ctx.fill();
                } else if (this.type === 'tree') {
                    const treeTypes = ['normal', 'palm', 'pine'];
                    const treeType = currentTheme === 'beach' ? 'palm' : (currentTheme === 'snow' ? 'pine' : treeTypes[this.variant % 3]);
                    
                    if (treeType === 'palm') {
                        // Palm tree
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(screenX + this.width/2 - 4, screenY + 10, 8, this.height - 10);
                        ctx.fillStyle = '#228b22';
                        for (let i = 0; i < 5; i++) {
                            ctx.save();
                            ctx.translate(screenX + this.width/2, screenY + 10);
                            ctx.rotate((i * Math.PI * 2 / 5) - Math.PI/2);
                            ctx.beginPath();
                            ctx.ellipse(0, -15, 8, 25, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    } else if (treeType === 'pine') {
                        // Pine tree
                        ctx.fillStyle = '#5c4033';
                        ctx.fillRect(screenX + this.width/2 - 4, screenY + this.height * 0.6, 8, this.height * 0.4);
                        ctx.fillStyle = '#1a4d1a';
                        ctx.beginPath();
                        ctx.moveTo(screenX + this.width/2, screenY);
                        ctx.lineTo(screenX + this.width, screenY + this.height * 0.7);
                        ctx.lineTo(screenX, screenY + this.height * 0.7);
                        ctx.fill();
                    } else {
                        // Normal tree
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(screenX + this.width/2 - 5, screenY + this.height/2, 10, this.height/2);
                        ctx.fillStyle = colors.tree;
                        ctx.beginPath();
                        ctx.arc(screenX + this.width/2, screenY + this.height/3, this.width/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'cactus') {
                    ctx.fillStyle = '#228b22';
                    // Main body
                    ctx.fillRect(screenX + this.width/2 - 8, screenY + 10, 16, this.height - 10);
                    // Arms
                    ctx.fillRect(screenX + this.width/2 + 8, screenY + 20, 15, 8);
                    ctx.fillRect(screenX + this.width/2 + 15, screenY + 10, 8, 18);
                    ctx.fillRect(screenX + this.width/2 - 23, screenY + 30, 15, 8);
                    ctx.fillRect(screenX + this.width/2 - 23, screenY + 20, 8, 18);
                } else if (this.type === 'mountain') {
                    ctx.fillStyle = '#8b7355';
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY + this.height);
                    ctx.lineTo(screenX + this.width/2, screenY);
                    ctx.lineTo(screenX + this.width, screenY + this.height);
                    ctx.fill();
                    // Snow cap
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width/2 - 15, screenY + 20);
                    ctx.lineTo(screenX + this.width/2, screenY);
                    ctx.lineTo(screenX + this.width/2 + 15, screenY + 20);
                    ctx.fill();
                } else if (this.type === 'river') {
                    ctx.fillStyle = colors.water;
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.strokeStyle = '#1E90FF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, this.width, this.height);
                } else if (this.type === 'lava') {
                    ctx.fillStyle = '#ff4500';
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    // Bubbles
                    ctx.fillStyle = '#ff6600';
                    const bubbleTime = Date.now() / 500;
                    for (let i = 0; i < 3; i++) {
                        const bx = screenX + 10 + (i * this.width/3) + Math.sin(bubbleTime + i) * 5;
                        const by = screenY + this.height/2 + Math.cos(bubbleTime + i) * 5;
                        ctx.beginPath();
                        ctx.arc(bx, by, 5 + Math.sin(bubbleTime) * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'volcano_center') {
                    // Massive volcano cone
                    const cx = screenX + this.width / 2;
                    const cy = screenY + this.height / 2;
                    
                    // Outer mountain
                    ctx.fillStyle = '#4a3020';
                    ctx.beginPath();
                    ctx.moveTo(screenX - 50, screenY + this.height + 50);
                    ctx.lineTo(cx, screenY - 80);
                    ctx.lineTo(screenX + this.width + 50, screenY + this.height + 50);
                    ctx.fill();
                    
                    // Inner darker layer
                    ctx.fillStyle = '#3a2015';
                    ctx.beginPath();
                    ctx.moveTo(screenX + 30, screenY + this.height);
                    ctx.lineTo(cx, screenY - 40);
                    ctx.lineTo(screenX + this.width - 30, screenY + this.height);
                    ctx.fill();
                    
                    // Crater opening (lava pool)
                    ctx.fillStyle = '#ff2200';
                    ctx.beginPath();
                    ctx.ellipse(cx, screenY - 20, 60, 30, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Animated lava glow
                    const glowPulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 100, 0, ${glowPulse * 0.5})`; 
                    ctx.beginPath();
                    ctx.ellipse(cx, screenY - 20, 80, 45, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Smoke particles rising
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';
                    for (let i = 0; i < 5; i++) {
                        const smokeY = screenY - 60 - ((Date.now() / 20 + i * 50) % 150);
                        const smokeX = cx + Math.sin(Date.now() / 500 + i) * 30;
                        const smokeSize = 15 + i * 5;
                        ctx.beginPath();
                        ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'runway') {
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    
                    // Edge lines (yellow)
                    ctx.strokeStyle = '#ffcc00';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    if (this.width > this.height) {
                        ctx.strokeRect(screenX + 2, screenY + 2, this.width - 4, this.height - 4);
                    } else {
                        ctx.strokeRect(screenX + 2, screenY + 2, this.width - 4, this.height - 4);
                    }
                    
                    // Center dashed line (white)
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([30, 20]);
                    ctx.beginPath();
                    if (this.width > this.height) {
                        ctx.moveTo(screenX, screenY + this.height/2);
                        ctx.lineTo(screenX + this.width, screenY + this.height/2);
                    } else {
                        ctx.moveTo(screenX + this.width/2, screenY);
                        ctx.lineTo(screenX + this.width/2, screenY + this.height);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Airport-style threshold markings (if on airport level)
                    if (currentLevel === 7 && this.width > 200) {
                        ctx.fillStyle = '#ffffff';
                        // Threshold bars at each end
                        for (let i = 0; i < 4; i++) {
                            ctx.fillRect(screenX + 15 + i * 25, screenY + 10, 15, this.height - 20);
                            ctx.fillRect(screenX + this.width - 115 + i * 25, screenY + 10, 15, this.height - 20);
                        }
                    }
                } else if (this.type === 'crater') {
                    // Moon crater
                    ctx.fillStyle = '#707070';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width/2, screenY + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#606060';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width/2, screenY + this.height/2, this.width/3, this.height/3, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'impact_crater') {
                    // Fresh asteroid impact crater - darker with scorched edges
                    ctx.fillStyle = '#404040';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width/2, screenY + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Scorched ring
                    ctx.strokeStyle = '#2a2020';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width/2, screenY + this.height/2, this.width/2 - 3, this.height/2 - 3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    // Inner crater
                    ctx.fillStyle = '#303030';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width/2, screenY + this.height/2, this.width/4, this.height/4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Debris particles
                    ctx.fillStyle = '#555';
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const dist = this.width * 0.35;
                        const px = screenX + this.width/2 + Math.cos(angle) * dist;
                        const py = screenY + this.height/2 + Math.sin(angle) * dist;
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'moon_base') {
                    // Dome building
                    ctx.fillStyle = '#c0c0c0';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width/2, screenY + this.height, this.width/2, Math.PI, 0);
                    ctx.fill();
                    ctx.fillStyle = '#4a6a8a';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width/2, screenY + this.height - 10, 15, Math.PI, 0);
                    ctx.fill();
                } else if (this.type === 'asteroid') {
                    ctx.fillStyle = '#5a5a6a';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width/2, screenY + this.height/2, this.width/2, this.height/2, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Craters on asteroid
                    ctx.fillStyle = '#4a4a5a';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width/3, screenY + this.height/3, 5, 0, Math.PI * 2);
                    ctx.arc(screenX + this.width*2/3, screenY + this.height*2/3, 7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'star_cluster') {
                    // Decorative - doesn't block
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 5; i++) {
                        const sx = screenX + Math.random() * this.width;
                        const sy = screenY + Math.random() * this.height;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 1 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'raised') {
                    ctx.fillStyle = colors.raised;
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.strokeStyle = '#2d4027';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(screenX, screenY, this.width, this.height);
                } else if (this.type === 'ramp') {
                    const gradient = ctx.createLinearGradient(screenX, screenY, screenX + this.width, screenY);
                    gradient.addColorStop(0, colors.ground);
                    gradient.addColorStop(1, colors.raised);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, this.width, this.height);
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const arrows = { right: '‚ñ∂', left: '‚óÄ', up: '‚ñ≤', down: '‚ñº' };
                    ctx.fillText(arrows[this.rampDir] || '‚ñ∂', screenX + this.width/2, screenY + this.height/2);
                } else if (this.type === 'island') {
                    // Sandy island
                    ctx.fillStyle = '#f5deb3';
                    ctx.beginPath();
                    ctx.ellipse(screenX + this.width/2, screenY + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Palm tree on island
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(screenX + this.width/2 - 3, screenY + this.height/2 - 20, 6, 25);
                    ctx.fillStyle = '#228b22';
                    for (let i = 0; i < 4; i++) {
                        ctx.save();
                        ctx.translate(screenX + this.width/2, screenY + this.height/2 - 20);
                        ctx.rotate(i * Math.PI / 2);
                        ctx.beginPath();
                        ctx.ellipse(0, -10, 5, 15, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
        }

        // Special entities for specific levels
        class Animal {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'camel', 'scorpion', 'snake'
                this.width = 40;
                this.height = 30;
                this.health = 10;
                this.alive = true;
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.wanderTimer = 0;
            }

            update() {
                if (!this.alive) return;
                this.wanderTimer++;
                if (this.wanderTimer > 60) {
                    this.wanderAngle += (Math.random() - 0.5) * 1;
                    this.wanderTimer = 0;
                }
                this.x += Math.cos(this.wanderAngle) * 0.3;
                this.y += Math.sin(this.wanderAngle) * 0.3;
                this.x = Math.max(50, Math.min(MAP_WIDTH - 50, this.x));
                this.y = Math.max(50, Math.min(MAP_HEIGHT - 50, this.y));
            }

            draw() {
                if (!this.alive) return;
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                if (this.type === 'camel') {
                    ctx.fillStyle = '#c4a35a';
                    // Body
                    ctx.fillRect(screenX - 15, screenY - 5, 30, 15);
                    // Humps
                    ctx.beginPath();
                    ctx.arc(screenX - 5, screenY - 10, 8, 0, Math.PI, true);
                    ctx.arc(screenX + 8, screenY - 10, 8, 0, Math.PI, true);
                    ctx.fill();
                    // Head
                    ctx.fillRect(screenX + 15, screenY - 10, 10, 8);
                    // Legs
                    ctx.fillRect(screenX - 12, screenY + 10, 4, 12);
                    ctx.fillRect(screenX + 8, screenY + 10, 4, 12);
                } else if (this.type === 'scorpion') {
                    ctx.fillStyle = '#4a3728';
                    ctx.beginPath();
                    ctx.ellipse(screenX, screenY, 12, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail
                    ctx.beginPath();
                    ctx.moveTo(screenX - 12, screenY);
                    ctx.quadraticCurveTo(screenX - 25, screenY - 20, screenX - 20, screenY - 25);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#4a3728';
                    ctx.stroke();
                    // Claws
                    ctx.fillStyle = '#4a3728';
                    ctx.beginPath();
                    ctx.arc(screenX + 15, screenY - 5, 5, 0, Math.PI * 2);
                    ctx.arc(screenX + 15, screenY + 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'snake') {
                    ctx.strokeStyle = '#567d46';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(screenX - 15, screenY);
                    ctx.quadraticCurveTo(screenX - 5, screenY - 10, screenX + 5, screenY);
                    ctx.quadraticCurveTo(screenX + 15, screenY + 10, screenX + 20, screenY);
                    ctx.stroke();
                    // Head
                    ctx.fillStyle = '#567d46';
                    ctx.beginPath();
                    ctx.arc(screenX + 20, screenY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Plane {
            constructor() {
                this.x = Math.random() < 0.5 ? -100 : MAP_WIDTH + 100;
                this.y = Math.random() * MAP_HEIGHT;
                this.speed = 3 + Math.random() * 2;
                this.direction = this.x < 0 ? 1 : -1;
                this.width = 80;
                this.height = 30;
                this.lastShot = 0;
                this.shootCooldown = 2000;
            }

            update() {
                this.x += this.speed * this.direction;
                
                // Shoot at player if close enough
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const now = Date.now();
                if (dist < 400 && now - this.lastShot > this.shootCooldown) {
                    this.shoot();
                    this.lastShot = now;
                }
                
                // Respawn when off screen
                if (this.x < -200 || this.x > MAP_WIDTH + 200) {
                    this.x = this.direction > 0 ? -100 : MAP_WIDTH + 100;
                    this.y = Math.random() * MAP_HEIGHT;
                    this.direction *= -1;
                }
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                if (this.direction < 0) ctx.scale(-1, 1);
                
                // Fuselage
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.ellipse(0, 0, 40, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings
                ctx.fillStyle = '#c0c0c0';
                ctx.fillRect(-15, -25, 30, 50);
                
                // Tail
                ctx.fillRect(-35, -15, 10, 30);
                
                // Cockpit
                ctx.fillStyle = '#4a90d9';
                ctx.beginPath();
                ctx.ellipse(25, 0, 10, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            shoot() {
                // Plane shoots at player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const angle = Math.atan2(dy, dx);
                enemyBullets.push(new Bullet(this.x, this.y, angle, 'enemy', false));
            }
        }
        
        class DustParticle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * MAP_WIDTH;
                this.y = Math.random() * MAP_HEIGHT;
                this.size = 2 + Math.random() * 4;
                this.speedX = 2 + Math.random() * 3;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.alpha = 0.3 + Math.random() * 0.4;
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                if (this.x > MAP_WIDTH + 50) {
                    this.x = -50;
                    this.y = Math.random() * MAP_HEIGHT;
                }
            }
            
            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                if (screenX < -50 || screenX > canvas.width + 50 || screenY < -50 || screenY > canvas.height + 50) return;
                
                ctx.fillStyle = `rgba(210, 180, 140, ${this.alpha})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class FireParticle {
            constructor(x, y) {
                this.baseX = x;
                this.baseY = y;
                this.x = x;
                this.y = y;
                this.size = 3 + Math.random() * 8;
                this.life = 60 + Math.random() * 60;
                this.maxLife = this.life;
                this.speedY = -1 - Math.random() * 2;
                this.speedX = (Math.random() - 0.5) * 1;
                this.flickerOffset = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.life--;
                this.y += this.speedY;
                this.x += this.speedX + Math.sin(Date.now() / 100 + this.flickerOffset) * 0.5;
                
                // Reset when life runs out
                if (this.life <= 0) {
                    this.x = this.baseX + (Math.random() - 0.5) * 30;
                    this.y = this.baseY;
                    this.life = 60 + Math.random() * 60;
                    this.maxLife = this.life;
                }
            }
            
            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                if (screenX < -50 || screenX > canvas.width + 50 || screenY < -50 || screenY > canvas.height + 50) return;
                
                const lifeRatio = this.life / this.maxLife;
                const flicker = Math.sin(Date.now() / 50 + this.flickerOffset) * 0.2 + 0.8;
                
                // Fire gradient: yellow -> orange -> red as it rises
                const r = 255;
                const g = Math.floor(255 * lifeRatio * 0.8);
                const b = 0;
                const alpha = lifeRatio * 0.8 * flicker;
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size * lifeRatio, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class IcePatch {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            
            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                // Ice patch with shiny surface
                ctx.fillStyle = 'rgba(180, 220, 255, 0.6)';
                ctx.fillRect(screenX, screenY, this.width, this.height);
                
                // Shine lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const lx = screenX + 20 + i * (this.width / 4);
                    ctx.beginPath();
                    ctx.moveTo(lx, screenY + 10);
                    ctx.lineTo(lx + 30, screenY + this.height - 10);
                    ctx.stroke();
                }
                
                // Border
                ctx.strokeStyle = 'rgba(100, 150, 200, 0.8)';
                ctx.lineWidth = 3;
                ctx.strokeRect(screenX, screenY, this.width, this.height);
            }
        }

        class Astronaut {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 35;
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.wanderTimer = 0;
                this.bounceOffset = 0;
            }

            update() {
                this.wanderTimer++;
                this.bounceOffset = Math.sin(Date.now() / 200) * 3; // Moon bounce
                if (this.wanderTimer > 90) {
                    this.wanderAngle += (Math.random() - 0.5) * 0.8;
                    this.wanderTimer = 0;
                }
                this.x += Math.cos(this.wanderAngle) * 0.2;
                this.y += Math.sin(this.wanderAngle) * 0.2;
                this.x = Math.max(50, Math.min(MAP_WIDTH - 50, this.x));
                this.y = Math.max(50, Math.min(MAP_HEIGHT - 50, this.y));
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y + this.bounceOffset;
                
                // Suit
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(screenX - 10, screenY - 5, 20, 25);
                
                // Helmet
                ctx.fillStyle = '#e0e0e0';
                ctx.beginPath();
                ctx.arc(screenX, screenY - 15, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Visor
                ctx.fillStyle = '#4a6a8a';
                ctx.beginPath();
                ctx.arc(screenX, screenY - 15, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Backpack
                ctx.fillStyle = '#c0c0c0';
                ctx.fillRect(screenX - 15, screenY - 5, 5, 20);
                
                // Legs
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(screenX - 8, screenY + 20, 6, 10);
                ctx.fillRect(screenX + 2, screenY + 20, 6, 10);
            }
        }
        
        class Meteor {
            constructor() {
                this.reset();
            }
            
            reset() {
                // Start from top or sides
                const startSide = Math.random();
                if (startSide < 0.5) {
                    this.x = Math.random() * MAP_WIDTH;
                    this.y = -50;
                } else if (startSide < 0.75) {
                    this.x = -50;
                    this.y = Math.random() * MAP_HEIGHT * 0.5;
                } else {
                    this.x = MAP_WIDTH + 50;
                    this.y = Math.random() * MAP_HEIGHT * 0.5;
                }
                
                this.size = 15 + Math.random() * 30;
                this.speed = 5 + Math.random() * 5;
                this.angle = Math.PI / 4 + (Math.random() - 0.5) * 0.5; // Diagonal down
                if (this.x > MAP_WIDTH / 2) this.angle = Math.PI - this.angle;
                this.trailLength = 6;
                this.trail = [];
                this.active = true;
                this.impactTimer = 0;
                this.impactX = 0;
                this.impactY = 0;
                this.craterCreated = false;
            }
            
            update() {
                if (!this.active) {
                    this.impactTimer--;
                    if (this.impactTimer <= 0) {
                        this.reset();
                    }
                    return;
                }
                
                // Store trail position
                this.trail.unshift({ x: this.x, y: this.y });
                if (this.trail.length > this.trailLength) this.trail.pop();
                
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Check if meteor hits ground (within map bounds)
                if (this.y > MAP_HEIGHT - 50 && this.x > 50 && this.x < MAP_WIDTH - 50) {
                    // Create impact
                    this.active = false;
                    this.impactX = this.x;
                    this.impactY = this.y;
                    this.impactTimer = 45;
                    
                    // Create permanent crater obstacle
                    if (!this.craterCreated) {
                        obstacles.push(new Obstacle(this.impactX - 40, this.impactY - 40, 80, 80, 'impact_crater'));
                        this.craterCreated = true;
                    }
                    
                    // KILL any enemies caught in the blast!
                    const blastRadius = 100;
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const dx = enemy.x - this.impactX;
                        const dy = enemy.y - this.impactY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < blastRadius) {
                            enemies.splice(i, 1);
                            score += 100; // Bonus for asteroid kill!
                        }
                    }
                    
                    // Damage player if close
                    const dx = player.x - this.impactX;
                    const dy = player.y - this.impactY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < blastRadius) {
                        player.health -= 20;
                    }
                } else if (this.y > MAP_HEIGHT + 100 || this.x < -100 || this.x > MAP_WIDTH + 100) {
                    // Meteor missed the map, just reset
                    this.reset();
                }
            }
            
            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                if (!this.active) {
                    // Draw impact explosion
                    const alpha = this.impactTimer / 45;
                    // Shockwave
                    ctx.strokeStyle = `rgba(255, 150, 50, ${alpha})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(this.impactX - camera.x, this.impactY - camera.y, 100 * (1 - alpha) + 20, 0, Math.PI * 2);
                    ctx.stroke();
                    // Fire ball
                    ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(this.impactX - camera.x, this.impactY - camera.y, 50 * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    return;
                }
                
                // Draw trail
                this.trail.forEach((pos, i) => {
                    const trailAlpha = (1 - i / this.trailLength) * 0.6;
                    const trailSize = this.size * (1 - i / this.trailLength);
                    ctx.fillStyle = `rgba(255, ${150 - i * 20}, 0, ${trailAlpha})`;
                    ctx.beginPath();
                    ctx.arc(pos.x - camera.x, pos.y - camera.y, trailSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw meteor
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow
                ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size * 1.3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class MovingWater {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.waveOffset = Math.random() * Math.PI * 2;
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                const time = Date.now() / 1000;
                
                // Base water
                ctx.fillStyle = '#00ced1';
                ctx.fillRect(screenX, screenY, this.width, this.height);
                
                // Animated waves
                ctx.fillStyle = '#40e0d0';
                for (let i = 0; i < this.width; i += 20) {
                    const waveY = Math.sin(time * 2 + i / 30 + this.waveOffset) * 5;
                    ctx.beginPath();
                    ctx.arc(screenX + i + 10, screenY + this.height / 2 + waveY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Foam
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                for (let i = 0; i < this.width; i += 30) {
                    const foamY = Math.sin(time * 3 + i / 20) * 3;
                    ctx.beginPath();
                    ctx.arc(screenX + i + 15, screenY + 10 + foamY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class BossStatue {
            constructor(x, y, level) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 80;
                this.level = level;
                this.health = 100;
                this.maxHealth = 100;
                this.awakened = false;
                
                // Boss styling based on level
                const bossStyles = {
                    1: { color: '#228B22', name: 'CHUNKY MONKEY', symbol: 'ü¶ç' },
                    2: { color: '#8B4513', name: 'RUBBLE RUMBLER', symbol: 'üèöÔ∏è' },
                    3: { color: '#DAA520', name: 'SANDY CHEEKS', symbol: 'ü¶Ç' },
                    4: { color: '#00CED1', name: 'CRABBY PATTY', symbol: 'ü¶Ä' }
                };
                const style = bossStyles[level] || { color: '#ff00ff', name: 'BOSS', symbol: 'üíÄ' };
                this.color = style.color;
                this.bossName = style.name;
                this.symbol = style.symbol;
            }
            
            takeDamage(amount) {
                if (this.awakened) return;
                this.health -= amount;
                if (this.health <= 0) {
                    this.awaken();
                }
            }
            
            awaken() {
                this.awakened = true;
                // Spawn a boss at this location!
                const newBoss = new Boss(this.level);
                newBoss.x = this.x;
                newBoss.y = this.y;
                // Make arena bosses tougher
                newBoss.health = 200;
                newBoss.maxHealth = 200;
                // Add to enemies array so it attacks everyone
                if (!boss) {
                    boss = newBoss;
                } else {
                    // If there's already a boss, add this one as a special enemy
                    enemies.push({
                        ...newBoss,
                        type: 'arenaBoss',
                        width: 70,
                        height: 70,
                        update: newBoss.update.bind(newBoss),
                        draw: newBoss.draw.bind(newBoss)
                    });
                }
                showPowerupPopup('‚ö†Ô∏è ' + this.bossName + ' HAS AWAKENED!');
            }
            
            draw() {
                if (this.awakened) return;
                
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                // Stone pedestal
                ctx.fillStyle = '#555555';
                ctx.fillRect(screenX - this.width/2 - 10, screenY + this.height/2 - 20, this.width + 20, 30);
                
                // Statue body (stone colored version of boss)
                ctx.fillStyle = '#888888';
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Cracked stone texture
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX - 20, screenY - 10);
                ctx.lineTo(screenX + 5, screenY + 15);
                ctx.moveTo(screenX + 10, screenY - 20);
                ctx.lineTo(screenX - 5, screenY + 10);
                ctx.stroke();
                
                // Boss symbol
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, screenX, screenY);
                
                // Glowing eyes based on damage
                const glowIntensity = 1 - (this.health / this.maxHealth);
                if (glowIntensity > 0) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${glowIntensity})`;
                    ctx.beginPath();
                    ctx.arc(screenX - 12, screenY - 10, 5, 0, Math.PI * 2);
                    ctx.arc(screenX + 12, screenY - 10, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Health bar
                const barWidth = this.width;
                const barHeight = 8;
                const barX = screenX - barWidth/2;
                const barY = screenY - this.height/2 - 15;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = this.health > 30 ? '#00ff00' : '#ff0000';
                ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Name label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 10px Arial';
                ctx.fillText(this.bossName, screenX, barY - 5);
            }
        }
        
        class ConveyorBelt {
            constructor(x, y, width, height, direction) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.direction = direction; // 'up', 'down', 'left', 'right'
                this.speed = 3;
                this.animOffset = 0;
            }
            
            update() {
                this.animOffset = (this.animOffset + 2) % 20;
            }
            
            applyForce(entity) {
                const entityRect = { x: entity.x - 20, y: entity.y - 20, width: 40, height: 40 };
                if (checkCollision(entityRect, this)) {
                    switch(this.direction) {
                        case 'up': entity.y -= this.speed; break;
                        case 'down': entity.y += this.speed; break;
                        case 'left': entity.x -= this.speed; break;
                        case 'right': entity.x += this.speed; break;
                    }
                }
            }
            
            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                // Belt base
                ctx.fillStyle = '#444444';
                ctx.fillRect(screenX, screenY, this.width, this.height);
                
                // Belt surface
                ctx.fillStyle = '#666666';
                ctx.fillRect(screenX + 4, screenY + 4, this.width - 8, this.height - 8);
                
                // Animated arrows showing direction
                ctx.fillStyle = '#ffcc00';
                const arrowSize = 15;
                
                if (this.direction === 'right' || this.direction === 'left') {
                    for (let i = -20; i < this.width + 20; i += 30) {
                        const offset = this.direction === 'right' ? this.animOffset : -this.animOffset;
                        const ax = screenX + ((i + offset) % this.width);
                        if (ax >= screenX && ax <= screenX + this.width - arrowSize) {
                            ctx.beginPath();
                            if (this.direction === 'right') {
                                ctx.moveTo(ax, screenY + this.height/2 - 8);
                                ctx.lineTo(ax + arrowSize, screenY + this.height/2);
                                ctx.lineTo(ax, screenY + this.height/2 + 8);
                            } else {
                                ctx.moveTo(ax + arrowSize, screenY + this.height/2 - 8);
                                ctx.lineTo(ax, screenY + this.height/2);
                                ctx.lineTo(ax + arrowSize, screenY + this.height/2 + 8);
                            }
                            ctx.fill();
                        }
                    }
                } else {
                    for (let i = -20; i < this.height + 20; i += 30) {
                        const offset = this.direction === 'down' ? this.animOffset : -this.animOffset;
                        const ay = screenY + ((i + offset) % this.height);
                        if (ay >= screenY && ay <= screenY + this.height - arrowSize) {
                            ctx.beginPath();
                            if (this.direction === 'down') {
                                ctx.moveTo(screenX + this.width/2 - 8, ay);
                                ctx.lineTo(screenX + this.width/2, ay + arrowSize);
                                ctx.lineTo(screenX + this.width/2 + 8, ay);
                            } else {
                                ctx.moveTo(screenX + this.width/2 - 8, ay + arrowSize);
                                ctx.lineTo(screenX + this.width/2, ay);
                                ctx.lineTo(screenX + this.width/2 + 8, ay + arrowSize);
                            }
                            ctx.fill();
                        }
                    }
                }
                
                // Edge rails
                ctx.fillStyle = '#888888';
                if (this.direction === 'right' || this.direction === 'left') {
                    ctx.fillRect(screenX, screenY, this.width, 4);
                    ctx.fillRect(screenX, screenY + this.height - 4, this.width, 4);
                } else {
                    ctx.fillRect(screenX, screenY, 4, this.height);
                    ctx.fillRect(screenX + this.width - 4, screenY, 4, this.height);
                }
            }
        }

        class Bullet {
            constructor(x, y, angle, owner, elevated = false) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                // Player bullets get speed bonus from permanent upgrade
                this.speed = owner === 'player' ? 8 + player.bulletSpeedBonus : 8;
                this.radius = 4;
                this.owner = owner;
                this.elevated = elevated;
                this.homing = false;
            }

            update() {
                if (this.homing && this.owner === 'boss') {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const targetAngle = Math.atan2(dy, dx);
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    // Weaker homing - easier to dodge
                    this.angle += angleDiff * 0.012;
                }
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Bullets collide with solid obstacles
                for (let obstacle of obstacles) {
                    const bulletRect = { x: this.x - this.radius, y: this.y - this.radius, width: this.radius * 2, height: this.radius * 2 };
                    // Buildings, trees, mountains always block bullets
                    if (obstacle.type === 'building' || obstacle.type === 'tree' || obstacle.type === 'mountain' || obstacle.type === 'volcano_center') {
                        if (checkCollision(bulletRect, obstacle)) {
                            this.destroyed = true;
                            return;
                        }
                    }
                    // Raised platforms only block non-elevated bullets
                    if (!this.elevated && obstacle.type === 'raised') {
                        if (checkCollision(bulletRect, obstacle)) {
                            this.destroyed = true;
                            return;
                        }
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.owner === 'player' ? '#ffff00' : 
                               (this.owner === 'ally' ? '#00ff00' :
                               (this.owner === 'boss' ? '#ff00ff' : '#ff0000'));
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.owner === 'boss' ? 6 : this.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            isOffScreen() {
                return this.destroyed || this.x < camera.x - 100 || this.x > camera.x + canvas.width + 100 || 
                       this.y < camera.y - 100 || this.y > camera.y + canvas.height + 100;
            }
        }

        class Enemy {
            constructor() {
                const variant = Math.random();
                if (variant < 0.15) {
                    this.type = 'fast';
                    this.width = 35;
                    this.height = 35;
                    this.speed = 0.7;
                    this.health = 25;
                    this.maxHealth = 25;
                    this.color = '#ff8c00';
                    this.shootCooldown = 1500;
                } else if (variant < 0.30) {
                    this.type = 'heavy';
                    this.width = 50;
                    this.height = 50;
                    this.speed = 0.3;
                    this.health = 60;
                    this.maxHealth = 60;
                    this.color = '#8b0000';
                    this.shootCooldown = 4000;
                } else if (variant < 0.40) {
                    this.type = 'sniper';
                    this.width = 35;
                    this.height = 35;
                    this.speed = 0.4;
                    this.health = 20;
                    this.maxHealth = 20;
                    this.color = '#4169e1';
                    this.shootCooldown = 2000;
                    this.range = 600;
                } else {
                    this.type = 'standard';
                    this.width = 40;
                    this.height = 40;
                    this.speed = 0.5;
                    this.health = 30;
                    this.maxHealth = 30;
                    this.color = '#ff0000';
                    this.shootCooldown = 3000;
                }
                
                this.lastShot = 0;
                this.elevated = false;
                this.range = this.range || 400;
                this.isHovercraft = false; // Can be set to true for beach level
                
                const side = Math.floor(Math.random() * 4);
                const margin = 150;
                if (side === 0) {
                    this.x = Math.random() * (MAP_WIDTH - 200) + 100;
                    this.y = margin;
                } else if (side === 1) {
                    this.x = MAP_WIDTH - margin;
                    this.y = Math.random() * (MAP_HEIGHT - 200) + 100;
                } else if (side === 2) {
                    this.x = Math.random() * (MAP_WIDTH - 200) + 100;
                    this.y = MAP_HEIGHT - margin;
                } else {
                    this.x = margin;
                    this.y = Math.random() * (MAP_HEIGHT - 200) + 100;
                }
                this.angle = 0;
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 200) {
                    let moveX = (dx / distance) * this.speed;
                    let moveY = (dy / distance) * this.speed;
                    
                    const testX = this.x + moveX;
                    const testY = this.y + moveY;
                    const checkRect = { x: testX - this.width / 2, y: testY - this.height / 2, width: this.width, height: this.height };
                    let canMove = true;
                    let onRamp = false;
                    let onRaised = false;
                    
                    for (let obstacle of obstacles) {
                        if (obstacle.type === 'ramp' && checkCollision(checkRect, obstacle)) onRamp = true;
                        if (obstacle.type === 'raised' && checkCollision(checkRect, obstacle)) onRaised = true;
                        if (obstacle.type === 'raised' && !this.elevated && !onRamp) {
                            if (checkCollision(checkRect, obstacle)) {
                                canMove = false;
                                break;
                            }
                        }
                        // Hovercrafts can cross water!
                        if (obstacle.type === 'river' && this.isHovercraft) continue;
                        if (obstacle.type === 'building' || obstacle.type === 'tree' || obstacle.type === 'river' || obstacle.type === 'mountain' || obstacle.type === 'volcano_center') {
                            if (checkCollision(checkRect, obstacle)) {
                                canMove = false;
                                break;
                            }
                        }
                    }
                    
                    if (canMove) {
                        this.x += moveX;
                        this.y += moveY;
                    }
                    this.elevated = onRaised || onRamp;
                }
                
                this.angle = Math.atan2(dy, dx);
                
                const now = Date.now();
                if (now - this.lastShot > this.shootCooldown && distance < this.range) {
                    this.shoot();
                    this.lastShot = now;
                }
            }

            shoot() {
                const bulletX = this.x + Math.cos(this.angle) * 30;
                const bulletY = this.y + Math.sin(this.angle) * 30;
                enemyBullets.push(new Bullet(bulletX, bulletY, this.angle, 'enemy', this.elevated));
            }

            draw() {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.angle);
                
                if (this.isHovercraft) {
                    // Hovercraft skirt (air cushion effect)
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(0, 5, this.width / 2 + 8, this.height / 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Animated hover effect
                    const hoverBob = Math.sin(Date.now() / 150) * 2;
                    ctx.translate(0, hoverBob);
                    
                    // Rounded hovercraft body
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.width / 2, this.height / 2 - 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cockpit bubble
                    ctx.fillStyle = '#88ddff';
                    ctx.beginPath();
                    ctx.ellipse(-5, -3, 10, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Propeller at back
                    ctx.fillStyle = '#444';
                    ctx.fillRect(this.width / 2 - 5, -8, 10, 16);
                    const propAngle = Date.now() / 30;
                    ctx.fillStyle = '#666';
                    ctx.save();
                    ctx.translate(this.width / 2, 0);
                    ctx.rotate(propAngle);
                    ctx.fillRect(-2, -12, 4, 24);
                    ctx.restore();
                } else {
                    // Normal tank
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.fillStyle = '#8b0000';
                    ctx.fillRect(0, -5, 25, 10);
                }
                ctx.restore();
                
                const healthWidth = 40;
                const healthHeight = 5;
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - camera.x - healthWidth / 2, this.y - camera.y - 30, healthWidth, healthHeight);
                ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : (healthPercent > 0.25 ? '#ff0' : '#f00');
                ctx.fillRect(this.x - camera.x - healthWidth / 2, this.y - camera.y - 30, healthWidth * healthPercent, healthHeight);
                
                if (this.isHovercraft) {
                    ctx.fillStyle = '#00ffff';
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('HOVER', this.x - camera.x, this.y - camera.y - 35);
                }
            }
        }
        
        class AllyTank {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 35;
                this.height = 35;
                this.speed = 3;
                this.health = 50;
                this.maxHealth = 50;
                this.color = '#00dd00';
                this.shootCooldown = 1200;
                this.lastShot = 0;
                this.angle = 0;
                this.target = null;
            }
            
            update() {
                // Find nearest enemy to attack
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                // Also check boss
                if (boss) {
                    const dx = boss.x - this.x;
                    const dy = boss.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = boss;
                    }
                }
                
                this.target = nearestEnemy;
                
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - this.x;
                    const dy = nearestEnemy.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    
                    // Move toward enemy if far, stay back if close
                    if (nearestDist > 250) {
                        const moveX = (dx / nearestDist) * this.speed;
                        const moveY = (dy / nearestDist) * this.speed;
                        
                        // Check collision
                        const testX = this.x + moveX;
                        const testY = this.y + moveY;
                        const checkRect = { x: testX - this.width / 2, y: testY - this.height / 2, width: this.width, height: this.height };
                        let canMove = true;
                        
                        for (let obstacle of obstacles) {
                            if (obstacle.type === 'building' || obstacle.type === 'tree' || obstacle.type === 'river' || obstacle.type === 'mountain') {
                                if (checkCollision(checkRect, obstacle)) {
                                    canMove = false;
                                    break;
                                }
                            }
                        }
                        
                        if (canMove) {
                            this.x += moveX;
                            this.y += moveY;
                        }
                    }
                    
                    // Shoot at enemy
                    const now = Date.now();
                    if (now - this.lastShot > this.shootCooldown && nearestDist < 400) {
                        this.shoot();
                        this.lastShot = now;
                    }
                } else {
                    // No enemies - follow player loosely
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 150) {
                        const moveX = (dx / dist) * this.speed;
                        const moveY = (dy / dist) * this.speed;
                        this.x += moveX;
                        this.y += moveY;
                    }
                    this.angle = Math.atan2(dy, dx);
                }
            }
            
            shoot() {
                const bulletX = this.x + Math.cos(this.angle) * 25;
                const bulletY = this.y + Math.sin(this.angle) * 25;
                // Ally bullets go into regular bullets array (they damage enemies)
                bullets.push(new Bullet(bulletX, bulletY, this.angle, 'ally', false));
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.angle);
                
                // Tank body - green with white outline
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                // Barrel
                ctx.fillStyle = '#006600';
                ctx.fillRect(0, -4, 22, 8);
                ctx.restore();
                
                // Health bar
                const healthWidth = 35;
                const healthHeight = 4;
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - camera.x - healthWidth / 2, this.y - camera.y - 25, healthWidth, healthHeight);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x - camera.x - healthWidth / 2, this.y - camera.y - 25, healthWidth * healthPercent, healthHeight);
                
                // "ALLY" label
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ALLY', this.x - camera.x, this.y - camera.y - 30);
            }
        }

        class Boss {
            constructor(level) {
                this.level = level;
                this.width = 70;
                this.height = 70;
                this.speed = 0.8;
                this.health = 150 + (level * 50);
                this.maxHealth = this.health;
                this.lastShot = 0;
                this.shootCooldown = 1500;
                this.elevated = false;
                this.specialTimer = 0;
                this.shieldActive = false;
                
                // Level-specific boss styling with unique shapes
                const bossStyles = {
                    1: { color: '#228B22', name: 'CHUNKY MONKEY', symbol: 'ü¶ç', shape: 'circle' },
                    2: { color: '#8B4513', name: 'RUBBLE RUMBLER', symbol: 'üèöÔ∏è', shape: 'hexagon' },
                    3: { color: '#DAA520', name: 'SANDY CHEEKS', symbol: 'ü¶Ç', shape: 'diamond' },
                    4: { color: '#00CED1', name: 'CRABBY PATTY', symbol: 'ü¶Ä', shape: 'octagon' },
                    5: { color: '#87CEEB', name: 'MR. FREEZE POP', symbol: '‚ùÑÔ∏è', shape: 'star' },
                    6: { color: '#FF4500', name: 'SPICY MEATBALL', symbol: 'üî•', shape: 'triangle' },
                    7: { color: '#C0C0C0', name: 'CAPTAIN TURBULENCE', symbol: '‚úàÔ∏è', shape: 'pentagon' },
                    8: { color: '#E8E8E8', name: 'MOON CHEESE', symbol: 'üßÄ', shape: 'crescent' },
                    9: { color: '#9400D3', name: 'THE BIG BANG', symbol: 'üí´', shape: 'spiral' }
                };
                const style = bossStyles[level] || { color: '#ff00ff', name: 'BOSS', symbol: 'üíÄ', shape: 'square' };
                this.color = style.color;
                this.bossName = style.name;
                this.symbol = style.symbol;
                this.shape = style.shape;
                
                this.abilities = {
                    multiShot: level >= 2,
                    fastMove: level >= 3,
                    rapidFire: level >= 4,
                    regenerate: level >= 5,
                    shield: level >= 6,
                    homingShots: level >= 7,
                    teleport: level >= 8,
                    multiBarrel: level >= 9,
                    ultimate: level >= 10
                };
                
                if (this.abilities.fastMove) this.speed = 1.2;
                if (this.abilities.rapidFire) this.shootCooldown = 800;
                if (this.abilities.ultimate) {
                    this.speed = 1.5;
                    this.shootCooldown = 500;
                    this.health *= 1.5;
                    this.maxHealth = this.health;
                }
                
                const side = Math.floor(Math.random() * 4);
                const margin = 100;
                if (side === 0) {
                    this.x = Math.random() * (MAP_WIDTH - 200) + 100;
                    this.y = margin;
                } else if (side === 1) {
                    this.x = MAP_WIDTH - margin;
                    this.y = Math.random() * (MAP_HEIGHT - 200) + 100;
                } else if (side === 2) {
                    this.x = Math.random() * (MAP_WIDTH - 200) + 100;
                    this.y = MAP_HEIGHT - margin;
                } else {
                    this.x = margin;
                    this.y = Math.random() * (MAP_HEIGHT - 200) + 100;
                }
                this.angle = 0;
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (this.abilities.regenerate && this.health < this.maxHealth) {
                    this.health += 0.05;
                }
                
                if (this.abilities.shield && this.health < this.maxHealth * 0.3) {
                    if (!this.shieldActive && Math.random() < 0.01) {
                        this.shieldActive = true;
                        this.shieldTimer = Date.now();
                    }
                }
                if (this.shieldActive && Date.now() - this.shieldTimer > 3000) {
                    this.shieldActive = false;
                }
                
                if (this.abilities.teleport && Math.random() < 0.002) {
                    this.x = Math.random() * (MAP_WIDTH - 200) + 100;
                    this.y = Math.random() * (MAP_HEIGHT - 200) + 100;
                }
                
                if (distance > 150) {
                    let moveX = (dx / distance) * this.speed;
                    let moveY = (dy / distance) * this.speed;
                    const testX = this.x + moveX;
                    const testY = this.y + moveY;
                    const checkRect = { x: testX - this.width / 2, y: testY - this.height / 2, width: this.width, height: this.height };
                    let canMove = true;
                    
                    for (let obstacle of obstacles) {
                        if (obstacle.type === 'building' || obstacle.type === 'tree' || obstacle.type === 'river' || obstacle.type === 'mountain' || obstacle.type === 'volcano_center') {
                            if (checkCollision(checkRect, obstacle)) {
                                canMove = false;
                                break;
                            }
                        }
                    }
                    
                    if (canMove) {
                        this.x += moveX;
                        this.y += moveY;
                    }
                }
                
                this.angle = Math.atan2(dy, dx);
                
                const now = Date.now();
                if (now - this.lastShot > this.shootCooldown && distance < 500) {
                    this.shoot();
                    this.lastShot = now;
                }
            }

            shoot() {
                if (this.abilities.multiBarrel) {
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        const bx = this.x + Math.cos(angle) * 40;
                        const by = this.y + Math.sin(angle) * 40;
                        const bullet = new Bullet(bx, by, angle, 'boss', this.elevated);
                        if (this.abilities.homingShots) bullet.homing = true;
                        enemyBullets.push(bullet);
                    }
                } else if (this.abilities.multiShot) {
                    for (let i = -1; i <= 1; i++) {
                        const spreadAngle = this.angle + (i * 0.2);
                        const bx = this.x + Math.cos(spreadAngle) * 40;
                        const by = this.y + Math.sin(spreadAngle) * 40;
                        const bullet = new Bullet(bx, by, spreadAngle, 'boss', this.elevated);
                        if (this.abilities.homingShots) bullet.homing = true;
                        enemyBullets.push(bullet);
                    }
                } else {
                    const bulletX = this.x + Math.cos(this.angle) * 40;
                    const bulletY = this.y + Math.sin(this.angle) * 40;
                    const bullet = new Bullet(bulletX, bulletY, this.angle, 'boss', this.elevated);
                    if (this.abilities.homingShots) bullet.homing = true;
                    enemyBullets.push(bullet);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                ctx.rotate(this.angle);
                
                if (this.shieldActive) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 2 + 15, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw distinctive boss body based on shape
                ctx.fillStyle = this.color;
                const r = this.width / 2;
                
                if (this.shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                } else if (this.shape === 'hexagon') {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 6;
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.shape === 'diamond') {
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, 0);
                    ctx.lineTo(0, r);
                    ctx.lineTo(-r, 0);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.shape === 'octagon') {
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 4) * i - Math.PI / 8;
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.shape === 'star') {
                    ctx.beginPath();
                    for (let i = 0; i < 10; i++) {
                        const rad = i % 2 === 0 ? r : r * 0.5;
                        const angle = (Math.PI / 5) * i - Math.PI / 2;
                        const px = Math.cos(angle) * rad;
                        const py = Math.sin(angle) * rad;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.shape === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(0, -r);
                    ctx.lineTo(r, r * 0.7);
                    ctx.lineTo(-r, r * 0.7);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.shape === 'pentagon') {
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.shape === 'crescent') {
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = themeColors[currentTheme].ground;
                    ctx.beginPath();
                    ctx.arc(r * 0.4, 0, r * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = this.color;
                } else if (this.shape === 'spiral') {
                    ctx.beginPath();
                    for (let i = 0; i < 720; i++) {
                        const angle = (i / 180) * Math.PI;
                        const rad = (i / 720) * r;
                        const px = Math.cos(angle) * rad;
                        const py = Math.sin(angle) * rad;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.lineWidth = 8;
                    ctx.strokeStyle = this.color;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                }
                
                // Barrel
                ctx.fillStyle = '#333';
                ctx.fillRect(r * 0.3, -6, r, 12);
                ctx.restore();
                
                // Draw symbol on boss (unrotated)
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x - camera.x, this.y - camera.y);
                
                const healthWidth = 90;
                const healthHeight = 8;
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - camera.x - healthWidth / 2, this.y - camera.y - 55, healthWidth, healthHeight);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - camera.x - healthWidth / 2, this.y - camera.y - 55, healthWidth * healthPercent, healthHeight);
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.bossName, this.x - camera.x, this.y - camera.y - 62);
            }
            
            takeDamage(amount) {
                if (this.shieldActive) return false;
                this.health -= amount;
                return true;
            }
        }

        // ============================================
        // PLAYER FUNCTIONS
        // ============================================
        function shoot() {
            // Can't shoot if eliminated (spectator mode)
            if (isEliminated) return;
            
            if (player.multishot) {
                // Triple shot spread
                for (let i = -1; i <= 1; i++) {
                    const spreadAngle = player.angle + (i * 0.15);
                    const bulletX = player.x + Math.cos(spreadAngle) * 30;
                    const bulletY = player.y + Math.sin(spreadAngle) * 30;
                    bullets.push(new Bullet(bulletX, bulletY, spreadAngle, 'player', player.elevated));
                }
            } else {
                const bulletX = player.x + Math.cos(player.angle) * 30;
                const bulletY = player.y + Math.sin(player.angle) * 30;
                bullets.push(new Bullet(bulletX, bulletY, player.angle, 'player', player.elevated));
            }
        }

        function updatePlayer() {
            let vx = 0;
            let vy = 0;
            
            if (keys['w'] || keys['arrowup']) vy = -1;
            if (keys['s'] || keys['arrowdown']) vy = 1;
            if (keys['a'] || keys['arrowleft']) vx = -1;
            if (keys['d'] || keys['arrowright']) vx = 1;
            
            if (vx !== 0 && vy !== 0) {
                vx *= 0.707;
                vy *= 0.707;
            }
            
            // Check if on street/runway (speed boost in town)
            let onStreet = false;
            if (currentLevel === 2) { // Town level
                for (let obstacle of obstacles) {
                    if (obstacle.type === 'runway') {
                        if (player.x > obstacle.x && player.x < obstacle.x + obstacle.width &&
                            player.y > obstacle.y && player.y < obstacle.y + obstacle.height) {
                            onStreet = true;
                            break;
                        }
                    }
                }
            }
            
            // Apply street speed boost
            const streetSpeedMultiplier = onStreet ? 1.6 : 1.0;
            
            // Check if on ice
            onIce = false;
            const playerCenterRect = { x: player.x - player.width / 4, y: player.y - player.height / 4, width: player.width / 2, height: player.height / 2 };
            for (let ice of icePatches) {
                if (player.x > ice.x && player.x < ice.x + ice.width &&
                    player.y > ice.y && player.y < ice.y + ice.height) {
                    onIce = true;
                    break;
                }
            }
            
            // Space level: momentum-based movement (reduced control)
            if (currentLevel === 9) {
                // Apply thrust when pressing keys (reduced effectiveness)
                playerVelX += vx * 0.15;
                playerVelY += vy * 0.15;
                // Very slow friction in space
                playerVelX *= 0.995;
                playerVelY *= 0.995;
                // Cap max velocity
                const maxVel = 8;
                playerVelX = Math.max(-maxVel, Math.min(maxVel, playerVelX));
                playerVelY = Math.max(-maxVel, Math.min(maxVel, playerVelY));
                vx = playerVelX / player.speed;
                vy = playerVelY / player.speed;
            }
            // Moon level: low gravity bouncy movement
            else if (currentLevel === 8) {
                // Moon has floaty, bouncy physics
                playerVelX += vx * 0.4;
                playerVelY += vy * 0.4;
                // Add subtle "bounce" when moving
                moonBounceTimer++;
                if (moonBounceTimer % 30 === 0) {
                    moonBounceVel = 2;
                }
                moonBounceVel *= 0.9;
                // More friction than space but less than normal
                playerVelX *= 0.92;
                playerVelY *= 0.92;
                // Cap velocity
                const maxVel = 7;
                playerVelX = Math.max(-maxVel, Math.min(maxVel, playerVelX));
                playerVelY = Math.max(-maxVel, Math.min(maxVel, playerVelY));
                vx = playerVelX / player.speed;
                vy = playerVelY / player.speed;
            }
            // Ice sliding physics - NO CONTROL until you leave ice
            else if (onIce) {
                // Only set initial velocity when first hitting ice
                if (Math.abs(playerVelX) < 0.1 && Math.abs(playerVelY) < 0.1) {
                    // Player just entered ice - capture their momentum
                    playerVelX = vx * player.speed * 1.5;
                    playerVelY = vy * player.speed * 1.5;
                }
                // IGNORE all input while on ice - just slide!
                // Almost no friction on ice
                playerVelX *= 0.998;
                playerVelY *= 0.998;
                vx = playerVelX / player.speed;
                vy = playerVelY / player.speed;
            } else {
                // Normal movement - reset velocity when not on ice/space/moon
                playerVelX = vx * player.speed * streetSpeedMultiplier;
                playerVelY = vy * player.speed * streetSpeedMultiplier;
            }
            
            const testX = player.x + vx * player.speed * streetSpeedMultiplier;
            const testY = player.y + vy * player.speed * streetSpeedMultiplier;
            const playerRect = { x: testX - player.width / 2, y: testY - player.height / 2, width: player.width, height: player.height };
            const currentRect = { x: player.x - player.width / 2, y: player.y - player.height / 2, width: player.width, height: player.height };
            
            let canMove = true;
            let onRampNew = false;
            let onRaisedNew = false;
            let onRampCurrent = false;
            let onRaisedCurrent = false;
            
            for (let obstacle of obstacles) {
                if (obstacle.type === 'ramp' && checkCollision(currentRect, obstacle)) onRampCurrent = true;
                if (obstacle.type === 'raised' && checkCollision(currentRect, obstacle)) onRaisedCurrent = true;
            }
            
            for (let obstacle of obstacles) {
                if (obstacle.type === 'ramp' && checkCollision(playerRect, obstacle)) onRampNew = true;
                if (obstacle.type === 'raised' && checkCollision(playerRect, obstacle)) onRaisedNew = true;
            }
            
            if (onRaisedCurrent && !onRampCurrent) {
                if (!isFullyOnElevated(playerRect, obstacles)) canMove = false;
            }
            
            if (canMove && !onRaisedCurrent && !onRampCurrent && onRaisedNew && !onRampNew) {
                canMove = false;
            }
            
            if (canMove && !player.ghost) {
                for (let obstacle of obstacles) {
                    if (obstacle.type === 'river' && player.isHovercraft) continue;
                    if (obstacle.type === 'building' || obstacle.type === 'tree' || obstacle.type === 'river' || obstacle.type === 'mountain' || obstacle.type === 'volcano_center') {
                        if (checkCollision(playerRect, obstacle)) {
                            canMove = false;
                            // Stop velocity on collision
                            playerVelX = 0;
                            playerVelY = 0;
                            break;
                        }
                    }
                }
            }
            
            // Check movingWater collision (only hovercraft can cross)
            if (canMove && !player.ghost && !player.isHovercraft) {
                for (let water of movingWater) {
                    if (checkCollision(playerRect, water)) {
                        canMove = false;
                        playerVelX = 0;
                        playerVelY = 0;
                        break;
                    }
                }
            }
            
            if (canMove) {
                player.x = testX;
                player.y = testY;
            } else {
                // Stop velocity if can't move
                playerVelX = 0;
                playerVelY = 0;
            }
            
            // Check for lava - instant death!
            const lavaCheckRect = { x: player.x - player.width / 4, y: player.y - player.height / 4, width: player.width / 2, height: player.height / 2 };
            for (let obstacle of obstacles) {
                if (obstacle.type === 'lava' && checkCollision(lavaCheckRect, obstacle)) {
                    player.health = 0;
                    break;
                }
            }
            
            player.elevated = onRaisedNew || onRampNew;
            player.x = Math.max(player.width / 2, Math.min(MAP_WIDTH - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(MAP_HEIGHT - player.height / 2, player.y));
            
            const worldMouseX = mouseX + camera.x;
            const worldMouseY = mouseY + camera.y;
            player.angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x - camera.x, player.y - camera.y);
            ctx.rotate(player.angle);
            
            // Ghost mode when eliminated - only draw outline
            if (isEliminated) {
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                const size = Math.max(player.width, player.height) / 2;
                ctx.beginPath();
                switch(brSelectedShape) {
                    case 'triangle':
                        ctx.moveTo(size, 0);
                        ctx.lineTo(-size * 0.7, -size * 0.8);
                        ctx.lineTo(-size * 0.7, size * 0.8);
                        ctx.closePath();
                        break;
                    case 'circle':
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        break;
                    case 'diamond':
                        ctx.moveTo(size, 0);
                        ctx.lineTo(0, -size * 0.8);
                        ctx.lineTo(-size, 0);
                        ctx.lineTo(0, size * 0.8);
                        ctx.closePath();
                        break;
                    default:
                        ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);
                }
                ctx.stroke();
                ctx.restore();
                
                // Show ELIMINATED text
                const screenX = player.x - camera.x;
                const screenY = player.y - camera.y;
                ctx.globalAlpha = 0.5;
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.fillText('üëª SPECTATING', screenX, screenY - 35);
                ctx.globalAlpha = 1;
                return;
            }
            
            // Draw tank shape based on selected shape in battle mode
            ctx.fillStyle = player.color;
            if (isMultiplayer && multiplayerMode === 'battle') {
                drawTankShape(brSelectedShape, player.width, player.height);
            } else {
                ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
            }
            
            const barrelColor = player.isHovercraft ? '#00AAFF' : '#00aa00';
            ctx.fillStyle = barrelColor;
            ctx.fillRect(0, -5, 25, 10);
            ctx.restore();
            
            const healthWidth = 40;
            const healthHeight = 5;
            const healthPercent = player.health / player.maxHealth;
            ctx.fillStyle = '#000';
            ctx.fillRect(player.x - camera.x - healthWidth / 2, player.y - camera.y - 30, healthWidth, healthHeight);
            ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : (healthPercent > 0.25 ? '#ff0' : '#f00');
            ctx.fillRect(player.x - camera.x - healthWidth / 2, player.y - camera.y - 30, healthWidth * healthPercent, healthHeight);
            
            // In battle mode, show icon and player name
            if (isMultiplayer && multiplayerMode === 'battle' && brPlayerName) {
                const screenX = player.x - camera.x;
                const screenY = player.y - camera.y;
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(brSelectedIcon || 'üéñÔ∏è', screenX, screenY - 45);
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = '#00ff00';
                ctx.fillText(brPlayerName, screenX, screenY - 35);
            }
        }
        
        // Draw tank body shape based on shape type
        function drawTankShape(shape, width, height) {
            const size = Math.max(width, height) / 2;
            ctx.beginPath();
            
            switch(shape) {
                case 'triangle':
                    ctx.moveTo(size, 0);
                    ctx.lineTo(-size * 0.7, -size * 0.8);
                    ctx.lineTo(-size * 0.7, size * 0.8);
                    ctx.closePath();
                    break;
                case 'square':
                    ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);
                    break;
                case 'pentagon':
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 2 * Math.PI / 6);
                        const x = Math.cos(angle) * size;
                        const y = Math.sin(angle) * size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                case 'circle':
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    break;
                case 'diamond':
                    ctx.moveTo(size, 0);
                    ctx.lineTo(0, -size * 0.8);
                    ctx.lineTo(-size, 0);
                    ctx.lineTo(0, size * 0.8);
                    ctx.closePath();
                    break;
                default:
                    ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);
            }
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function resetPlayer() {
            player.health = 100;
            player.maxHealth = 100; // Reset max health
            player.isHovercraft = false;
            player.elevated = false;
            player.color = '#00ff00';
            player.shootCooldown = player.baseShootCooldown;
            player.speed = 5;
            player.x = MAP_WIDTH / 2;
            player.y = MAP_HEIGHT / 2;
            // Reset all powerup states
            player.shieldActive = false;
            player.damageBoost = false;
            player.ghost = false;
            player.multishot = false;
            // Reset permanent upgrades (they carry through levels but reset on new game)
            player.armorLevel = 0;
            player.bulletSpeedBonus = 0;
            player.magnetRange = 0;
            player.regenRate = 0;
            // Clear allies and permanent powerup tracking on new game
            allies.length = 0;
            permanentPowerups.length = 0;
        }

        function findSafeSpawn() {
            let spawnClear = false;
            let attempts = 0;
            
            while (!spawnClear && attempts < 50) {
                spawnClear = true;
                const playerRect = { 
                    x: player.x - player.width / 2 - 10, 
                    y: player.y - player.height / 2 - 10, 
                    width: player.width + 20, 
                    height: player.height + 20 
                };
                
                for (let obs of obstacles) {
                    if (obs.type === 'building' || obs.type === 'tree' || obs.type === 'river') {
                        if (checkCollision(playerRect, obs)) {
                            spawnClear = false;
                            break;
                        }
                    }
                }
                
                if (!spawnClear) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 50 + attempts * 20;
                    player.x = MAP_WIDTH / 2 + Math.cos(angle) * radius;
                    player.y = MAP_HEIGHT / 2 + Math.sin(angle) * radius;
                    player.x = Math.max(100, Math.min(MAP_WIDTH - 100, player.x));
                    player.y = Math.max(100, Math.min(MAP_HEIGHT - 100, player.y));
                }
                attempts++;
            }
        }

        // ============================================
        // MAP GENERATION
        // ============================================
        function generateMap() {
            obstacles.length = 0;
            upgrades.length = 0;
            animals.length = 0;
            planes.length = 0;
            astronauts.length = 0;
            movingWater.length = 0;
            dustParticles.length = 0;
            icePatches.length = 0;
            fireParticles.length = 0;
            meteors.length = 0;
            bossStatues.length = 0;
            conveyorBelts.length = 0;
            levelSpeedMultiplier = 1;
            playerVelX = 0;
            playerVelY = 0;
            lavaExpansionTimer = 0;
            
            function canPlace(x, y, w, h, padding = 20) {
                const testRect = { x: x - padding, y: y - padding, width: w + padding * 2, height: h + padding * 2 };
                for (let obs of obstacles) {
                    if (checkCollision(testRect, obs)) return false;
                }
                return true;
            }
            
            // Boundary walls (invisible for space level)
            if (currentLevel !== 9) {
                obstacles.push(new Obstacle(-100, -100, MAP_WIDTH + 200, 100, 'building'));
                obstacles.push(new Obstacle(-100, MAP_HEIGHT, MAP_WIDTH + 200, 100, 'building'));
                obstacles.push(new Obstacle(-100, 0, 100, MAP_HEIGHT, 'building'));
                obstacles.push(new Obstacle(MAP_WIDTH, 0, 100, MAP_HEIGHT, 'building'));
            }
            
            // Battle Royale gets special arena map
            if (isMultiplayer && multiplayerMode === 'battle') {
                generateBattleArenaMap(canPlace);
                clearSpawnArea();
                return; // Skip normal level generation
            }
            
            // Generate level-specific map
            switch(currentLevel) {
                case 1: generateJungleMap(canPlace); break;
                case 2: generateTownMap(canPlace); break;
                case 3: generateDesertMap(canPlace); break;
                case 4: generateBeachMap(canPlace); break;
                case 5: generateArcticMap(canPlace); break;
                case 6: generateVolcanoMap(canPlace); break;
                case 7: generateAirportMap(canPlace); break;
                case 8: generateMoonMap(canPlace); break;
                case 9: generateSpaceMap(canPlace); break;
            }
            
            // Clear spawn area as final safety
            clearSpawnArea();
            
            // Hovercraft upgrade (not on space levels)
            if (currentLevel < 7) {
                upgrades.push(new Upgrade(200, 200, 'hovercraft'));
            }
            
            // Initial powerups - more variety!
            const powerupCount = currentLevel >= 6 ? 10 : 7;
            const tempTypes = ['rapidfire', 'health', 'speed', 'shield', 'damage', 'ghost', 'multishot', 'magnet'];
            const permTypes = ['maxhealth', 'armor', 'bulletspeed', 'regen'];
            
            for (let i = 0; i < powerupCount; i++) {
                const px = Math.random() * (MAP_WIDTH - 200) + 100;
                const py = Math.random() * (MAP_HEIGHT - 200) + 100;
                // 25% chance for permanent powerup
                if (Math.random() < 0.25) {
                    powerups.push(new Powerup(px, py, permTypes[Math.floor(Math.random() * permTypes.length)]));
                } else {
                    powerups.push(new Powerup(px, py, tempTypes[Math.floor(Math.random() * tempTypes.length)]));
                }
            }
            
            // ALLY POWERUP - Available from town level onwards (level 2+)
            if (currentLevel >= 2) {
                const ax = Math.random() * (MAP_WIDTH - 400) + 200;
                const ay = Math.random() * (MAP_HEIGHT - 400) + 200;
                powerups.push(new Powerup(ax, ay, 'ally'));
            }
        }
        
        // LEVEL 2: THE TOWN - lots of buildings with streets in a grid
        function generateTownMap(canPlace) {
            // Create street grid first (using runway type for pavement)
            const streetWidth = 80;
            const blockSize = 250;
            
            // Main roads (horizontal)
            for (let y = blockSize; y < MAP_HEIGHT; y += blockSize) {
                obstacles.push(new Obstacle(0, y - streetWidth/2, MAP_WIDTH, streetWidth, 'runway'));
            }
            // Main roads (vertical)
            for (let x = blockSize; x < MAP_WIDTH; x += blockSize) {
                obstacles.push(new Obstacle(x - streetWidth/2, 0, streetWidth, MAP_HEIGHT, 'runway'));
            }
            
            // Buildings in city blocks with VARIED sizes (avoiding streets)
            let buildingsPlaced = 0;
            let attempts = 0;
            const buildingSizes = [
                { w: 40, h: 40 },   // Small house
                { w: 60, h: 50 },   // Medium house
                { w: 80, h: 60 },   // Large house
                { w: 100, h: 80 },  // Apartment block
                { w: 120, h: 100 }, // Office building
                { w: 50, h: 80 },   // Tall thin building
                { w: 90, h: 50 },   // Wide low building
            ];
            
            while (buildingsPlaced < 40 && attempts < 300) {
                const sizeType = buildingSizes[Math.floor(Math.random() * buildingSizes.length)];
                const bw = sizeType.w + (Math.random() - 0.5) * 20;
                const bh = sizeType.h + (Math.random() - 0.5) * 20;
                const bx = Math.random() * (MAP_WIDTH - bw - 100) + 50;
                const by = Math.random() * (MAP_HEIGHT - bh - 100) + 50;
                const distToCenter = Math.sqrt((bx + bw/2 - MAP_WIDTH/2) ** 2 + (by + bh/2 - MAP_HEIGHT/2) ** 2);
                
                // Check if on a street
                let onStreet = false;
                for (let y = blockSize; y < MAP_HEIGHT; y += blockSize) {
                    if (by < y + streetWidth/2 + 10 && by + bh > y - streetWidth/2 - 10) onStreet = true;
                }
                for (let x = blockSize; x < MAP_WIDTH; x += blockSize) {
                    if (bx < x + streetWidth/2 + 10 && bx + bw > x - streetWidth/2 - 10) onStreet = true;
                }
                
                if (!onStreet && distToCenter > 200 && canPlace(bx, by, bw, bh)) {
                    const building = new Obstacle(bx, by, bw, bh, 'building');
                    building.burned = Math.random() < 0.65; // 65% are burned/ruined!
                    building.floors = Math.floor(bh / 25) + 1;
                    obstacles.push(building);
                    buildingsPlaced++;
                    
                    // Add fire particles to some burned buildings
                    if (building.burned && Math.random() < 0.6) {
                        // Add multiple fire particles per burning building
                        for (let f = 0; f < 5 + Math.random() * 5; f++) {
                            const fx = bx + Math.random() * bw;
                            const fy = by + Math.random() * (bh * 0.5);
                            fireParticles.push(new FireParticle(fx, fy));
                        }
                    }
                }
                attempts++;
            }
            
            // Rubble piles (small obstacles scattered around)
            for (let i = 0; i < 15; i++) {
                const rx = Math.random() * (MAP_WIDTH - 80) + 40;
                const ry = Math.random() * (MAP_HEIGHT - 80) + 40;
                const distToCenter = Math.sqrt((rx - MAP_WIDTH/2) ** 2 + (ry - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 200 && canPlace(rx, ry, 30, 30, 10)) {
                    const rubble = new Obstacle(rx, ry, 20 + Math.random() * 25, 20 + Math.random() * 25, 'mountain');
                    obstacles.push(rubble);
                }
            }
            
            // A few surviving trees
            for (let i = 0; i < 5; i++) {
                const tx = Math.random() * (MAP_WIDTH - 100) + 50;
                const ty = Math.random() * (MAP_HEIGHT - 100) + 50;
                if (canPlace(tx, ty, 30, 30, 20)) {
                    obstacles.push(new Obstacle(tx, ty, 30, 30, 'tree'));
                }
            }
        }
        
        // BATTLE ARENA MAP - special map for multiplayer battle royale
        function generateBattleArenaMap(canPlace) {
            const centerX = MAP_WIDTH / 2;
            const centerY = MAP_HEIGHT / 2;
            
            // === BOSS STATUES IN EACH CORNER ===
            bossStatues.push(new BossStatue(120, 120, 1)); // Top-left: Jungle boss
            bossStatues.push(new BossStatue(MAP_WIDTH - 120, 120, 2)); // Top-right: Town boss
            bossStatues.push(new BossStatue(120, MAP_HEIGHT - 120, 3)); // Bottom-left: Desert boss
            bossStatues.push(new BossStatue(MAP_WIDTH - 120, MAP_HEIGHT - 120, 4)); // Bottom-right: Beach boss
            
            // === THE GREAT WALL with SNIPER TOWERS - northern section ===
            obstacles.push(new Obstacle(100, 250, 150, 50, 'building'));
            obstacles.push(new Obstacle(250, 250, 150, 50, 'building'));
            obstacles.push(new Obstacle(400, 250, 150, 50, 'building'));
            // Gap for passage
            obstacles.push(new Obstacle(650, 250, 150, 50, 'building'));
            obstacles.push(new Obstacle(800, 250, 150, 50, 'building'));
            obstacles.push(new Obstacle(950, 250, 150, 50, 'building'));
            obstacles.push(new Obstacle(1100, 250, 150, 50, 'building'));
            obstacles.push(new Obstacle(1250, 250, 150, 50, 'building'));
            // Wall SNIPER TOWERS (raised - can walk on top and shoot over wall)
            obstacles.push(new Obstacle(240, 180, 50, 120, 'raised'));
            obstacles.push(new Obstacle(190, 200, 50, 50, 'ramp'));
            obstacles.push(new Obstacle(540, 180, 50, 120, 'raised'));
            obstacles.push(new Obstacle(490, 200, 50, 50, 'ramp'));
            obstacles.push(new Obstacle(940, 180, 50, 120, 'raised'));
            obstacles.push(new Obstacle(990, 200, 50, 50, 'ramp'));
            obstacles.push(new Obstacle(1240, 180, 50, 120, 'raised'));
            obstacles.push(new Obstacle(1290, 200, 50, 50, 'ramp'));
            
            // === NORTHWEST - JUNGLE ZONE (no raised, just trees and river) ===
            obstacles.push(new Obstacle(200, 420, 70, 90, 'tree'));
            obstacles.push(new Obstacle(300, 480, 60, 80, 'tree'));
            obstacles.push(new Obstacle(220, 550, 55, 75, 'tree'));
            obstacles.push(new Obstacle(380, 400, 50, 70, 'tree'));
            obstacles.push(new Obstacle(280, 620, 65, 85, 'tree'));
            // River winding through jungle
            obstacles.push(new Obstacle(420, 350, 180, 45, 'river'));
            obstacles.push(new Obstacle(555, 350, 45, 200, 'river'));
            obstacles.push(new Obstacle(450, 505, 150, 45, 'river'));
            
            // === NORTHEAST - ICE ZONE (slippery, no raised) ===
            icePatches.push(new IcePatch(MAP_WIDTH - 500, 350, 350, 300));
            // Rocks scattered on ice for cover
            obstacles.push(new Obstacle(MAP_WIDTH - 450, 400, 60, 60, 'rock'));
            obstacles.push(new Obstacle(MAP_WIDTH - 300, 480, 50, 50, 'rock'));
            obstacles.push(new Obstacle(MAP_WIDTH - 200, 380, 55, 55, 'rock'));
            obstacles.push(new Obstacle(MAP_WIDTH - 350, 550, 45, 45, 'rock'));
            obstacles.push(new Obstacle(MAP_WIDTH - 230, 520, 50, 50, 'rock'));
            
            // === CENTRAL BUILDING COMPOUND (buildings for cover, not raised) ===
            obstacles.push(new Obstacle(centerX - 100, centerY - 100, 80, 80, 'building'));
            obstacles.push(new Obstacle(centerX + 30, centerY - 100, 80, 80, 'building'));
            obstacles.push(new Obstacle(centerX - 100, centerY + 30, 80, 80, 'building'));
            obstacles.push(new Obstacle(centerX + 30, centerY + 30, 80, 80, 'building'));
            // Central courtyard with one small raised sniper spot
            obstacles.push(new Obstacle(centerX - 30, centerY - 30, 60, 60, 'raised'));
            obstacles.push(new Obstacle(centerX - 30, centerY + 30, 60, 40, 'ramp'));
            
            // === BOTTOM AREA - CONVEYOR BELT FACTORY ZONE ===
            // Criss-crossing conveyor belts instead of lakes
            // Horizontal belts
            conveyorBelts.push(new ConveyorBelt(200, MAP_HEIGHT - 400, 400, 50, 'right'));
            conveyorBelts.push(new ConveyorBelt(200, MAP_HEIGHT - 250, 400, 50, 'left'));
            conveyorBelts.push(new ConveyorBelt(MAP_WIDTH - 600, MAP_HEIGHT - 400, 400, 50, 'left'));
            conveyorBelts.push(new ConveyorBelt(MAP_WIDTH - 600, MAP_HEIGHT - 250, 400, 50, 'right'));
            // Vertical belts connecting them
            conveyorBelts.push(new ConveyorBelt(550, MAP_HEIGHT - 400, 50, 150, 'down'));
            conveyorBelts.push(new ConveyorBelt(MAP_WIDTH - 250, MAP_HEIGHT - 400, 50, 150, 'down'));
            // Center crossing belt
            conveyorBelts.push(new ConveyorBelt(centerX - 150, MAP_HEIGHT - 320, 300, 40, 'right'));
            
            // Factory buildings around conveyors
            obstacles.push(new Obstacle(150, MAP_HEIGHT - 450, 60, 40, 'building'));
            obstacles.push(new Obstacle(MAP_WIDTH - 210, MAP_HEIGHT - 450, 60, 40, 'building'));
            obstacles.push(new Obstacle(centerX - 40, MAP_HEIGHT - 450, 80, 50, 'building'));
            
            // === SOUTHEAST - DESERT ZONE ===
            // Cacti scattered around
            obstacles.push(new Obstacle(MAP_WIDTH - 400, MAP_HEIGHT - 500, 45, 70, 'cactus'));
            obstacles.push(new Obstacle(MAP_WIDTH - 280, MAP_HEIGHT - 550, 40, 60, 'cactus'));
            obstacles.push(new Obstacle(MAP_WIDTH - 480, MAP_HEIGHT - 480, 50, 75, 'cactus'));
            // Small mountain for cover
            obstacles.push(new Obstacle(MAP_WIDTH - 320, MAP_HEIGHT - 600, 100, 80, 'mountain'));
            // Desert animals
            const desertAnimals = ['camel', 'scorpion', 'snake'];
            for (let i = 0; i < 4; i++) {
                animals.push(new Animal(
                    MAP_WIDTH - 450 + Math.random() * 300,
                    MAP_HEIGHT - 600 + Math.random() * 200,
                    desertAnimals[Math.floor(Math.random() * desertAnimals.length)]
                ));
            }
            
            // === EAST SIDE - Sniper ridge (one raised platform) ===
            obstacles.push(new Obstacle(MAP_WIDTH - 200, centerY - 100, 120, 200, 'raised'));
            obstacles.push(new Obstacle(MAP_WIDTH - 280, centerY - 50, 80, 100, 'ramp'));
            
            // === WEST SIDE - Jungle animals and trees ===
            obstacles.push(new Obstacle(180, centerY - 80, 60, 80, 'tree'));
            obstacles.push(new Obstacle(250, centerY + 40, 55, 75, 'tree'));
            obstacles.push(new Obstacle(200, centerY + 120, 50, 70, 'tree'));
            // Jungle animals
            const jungleAnimals = ['monkey', 'parrot', 'frog'];
            for (let i = 0; i < 3; i++) {
                animals.push(new Animal(
                    180 + Math.random() * 150,
                    centerY - 100 + Math.random() * 250,
                    jungleAnimals[Math.floor(Math.random() * jungleAnimals.length)]
                ));
            }
            
            // === SMALL WATER FEATURE - South center (smaller than before) ===
            movingWater.push(new MovingWater(centerX - 100, MAP_HEIGHT - 150, 200, 100));
            // Beach/runway strip
            obstacles.push(new Obstacle(centerX - 80, MAP_HEIGHT - 180, 160, 30, 'runway'));
            
            // === SCATTERED COVER throughout map ===
            obstacles.push(new Obstacle(550, 450, 55, 55, 'rock'));
            obstacles.push(new Obstacle(850, 600, 50, 50, 'rock'));
            obstacles.push(new Obstacle(450, 700, 60, 60, 'rock'));
            obstacles.push(new Obstacle(950, 700, 55, 55, 'rock'));
            obstacles.push(new Obstacle(650, 550, 55, 75, 'tree'));
            obstacles.push(new Obstacle(750, 450, 50, 70, 'tree'));
            
            // === ALLY POWERUPS scattered in hard-to-reach places ===
            // On sniper towers at the top
            powerups.push(new Powerup(260, 220, 'ally'));
            powerups.push(new Powerup(1260, 220, 'ally'));
            // Near edges of map
            powerups.push(new Powerup(80, MAP_HEIGHT - 80, 'ally'));
            powerups.push(new Powerup(MAP_WIDTH - 80, 500, 'ally'));
            // On central raised platform
            powerups.push(new Powerup(centerX, centerY, 'ally'));
            
            // === DUST PARTICLES ===
            for (let i = 0; i < 30; i++) {
                dustParticles.push(new DustParticle());
            }
        }
        
        // LEVEL 1: THE JUNGLE - wooden buildings, varied trees, rivers, mountain
        function generateJungleMap(canPlace) {
            // Central mountain
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 100, 200, 180, 150, 'mountain'));
            
            // Rivers winding through
            obstacles.push(new Obstacle(100, 400, 500, 50, 'river'));
            obstacles.push(new Obstacle(550, 400, 50, 300, 'river'));
            obstacles.push(new Obstacle(550, 650, 400, 50, 'river'));
            obstacles.push(new Obstacle(800, 900, 50, 300, 'river'));
            
            // Few wooden buildings
            for (let i = 0; i < 5; i++) {
                const bx = Math.random() * (MAP_WIDTH - 150) + 50;
                const by = Math.random() * (MAP_HEIGHT - 150) + 50;
                const distToCenter = Math.sqrt((bx - MAP_WIDTH/2) ** 2 + (by - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 250 && canPlace(bx, by, 60, 50)) {
                    obstacles.push(new Obstacle(bx, by, 60, 50, 'wooden_building'));
                }
            }
            
            // Lots of varied trees
            let treesPlaced = 0;
            let attempts = 0;
            while (treesPlaced < 40 && attempts < 200) {
                const tx = Math.random() * (MAP_WIDTH - 100) + 50;
                const ty = Math.random() * (MAP_HEIGHT - 100) + 50;
                const distToCenter = Math.sqrt((tx - MAP_WIDTH/2) ** 2 + (ty - MAP_HEIGHT/2) ** 2);
                const size = 30 + Math.random() * 30;
                
                if (distToCenter > 200 && canPlace(tx, ty, size, size, 20)) {
                    obstacles.push(new Obstacle(tx, ty, size, size, 'tree'));
                    treesPlaced++;
                }
                attempts++;
            }
        }
        
        // LEVEL 3: THE DESERT - cactuses, mountains, animals
        function generateDesertMap(canPlace) {
            // Mountains around edges
            for (let i = 0; i < 6; i++) {
                const mx = i < 3 ? 50 + Math.random() * 200 : MAP_WIDTH - 250 + Math.random() * 200;
                const my = Math.random() * (MAP_HEIGHT - 200) + 100;
                obstacles.push(new Obstacle(mx, my, 100 + Math.random() * 50, 120 + Math.random() * 60, 'mountain'));
            }
            
            // Cactuses everywhere
            let cactusPlaced = 0;
            let attempts = 0;
            while (cactusPlaced < 30 && attempts < 150) {
                const cx = Math.random() * (MAP_WIDTH - 100) + 50;
                const cy = Math.random() * (MAP_HEIGHT - 100) + 50;
                const distToCenter = Math.sqrt((cx - MAP_WIDTH/2) ** 2 + (cy - MAP_HEIGHT/2) ** 2);
                
                if (distToCenter > 200 && canPlace(cx, cy, 50, 60, 30)) {
                    obstacles.push(new Obstacle(cx, cy, 50, 60, 'cactus'));
                    cactusPlaced++;
                }
                attempts++;
            }
            
            // Desert animals
            const animalTypes = ['camel', 'scorpion', 'snake'];
            for (let i = 0; i < 8; i++) {
                const ax = Math.random() * (MAP_WIDTH - 200) + 100;
                const ay = Math.random() * (MAP_HEIGHT - 200) + 100;
                animals.push(new Animal(ax, ay, animalTypes[Math.floor(Math.random() * animalTypes.length)]));
            }
            
            // Dust particles blowing through
            for (let i = 0; i < 50; i++) {
                dustParticles.push(new DustParticle());
            }
        }
        
        // LEVEL 4: THE BEACH - complicated coastline, hovercraft enemies
        function generateBeachMap(canPlace) {
            // Complicated coastline with bays and peninsulas
            // Main ocean (irregular shape)
            movingWater.push(new MovingWater(MAP_WIDTH - 400, 0, 400, 400));
            obstacles.push(new Obstacle(MAP_WIDTH - 400, 0, 400, 400, 'river'));
            
            // Bay cutting into land
            movingWater.push(new MovingWater(MAP_WIDTH - 550, 400, 250, 300));
            obstacles.push(new Obstacle(MAP_WIDTH - 550, 400, 250, 300, 'river'));
            
            // Peninsula sticking out
            movingWater.push(new MovingWater(MAP_WIDTH - 400, 700, 400, 200));
            obstacles.push(new Obstacle(MAP_WIDTH - 400, 700, 400, 200, 'river'));
            
            // Another bay lower down
            movingWater.push(new MovingWater(MAP_WIDTH - 500, 900, 300, 250));
            obstacles.push(new Obstacle(MAP_WIDTH - 500, 900, 300, 250, 'river'));
            
            // Bottom ocean
            movingWater.push(new MovingWater(MAP_WIDTH - 350, 1150, 350, 350));
            obstacles.push(new Obstacle(MAP_WIDTH - 350, 1150, 350, 350, 'river'));
            
            // Tidal pools / lagoons
            movingWater.push(new MovingWater(MAP_WIDTH - 700, 550, 120, 100));
            obstacles.push(new Obstacle(MAP_WIDTH - 700, 550, 120, 100, 'river'));
            
            // Islands in the water
            obstacles.push(new Obstacle(MAP_WIDTH - 280, 150, 140, 140, 'island'));
            obstacles.push(new Obstacle(MAP_WIDTH - 350, 780, 160, 100, 'island'));
            obstacles.push(new Obstacle(MAP_WIDTH - 200, 1050, 100, 80, 'island'));
            
            // Rocky outcrops along shore
            for (let i = 0; i < 8; i++) {
                const rx = MAP_WIDTH - 450 - Math.random() * 200;
                const ry = Math.random() * MAP_HEIGHT;
                if (canPlace(rx, ry, 40, 40, 20)) {
                    obstacles.push(new Obstacle(rx, ry, 30 + Math.random() * 30, 30 + Math.random() * 30, 'mountain'));
                }
            }
            
            // Palm trees scattered on beach
            for (let i = 0; i < 25; i++) {
                const tx = Math.random() * (MAP_WIDTH - 550) + 50;
                const ty = Math.random() * (MAP_HEIGHT - 100) + 50;
                const distToCenter = Math.sqrt((tx - MAP_WIDTH/2) ** 2 + (ty - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 200 && canPlace(tx, ty, 40, 50, 30)) {
                    obstacles.push(new Obstacle(tx, ty, 40, 50, 'tree'));
                }
            }
            
            // Beach huts
            for (let i = 0; i < 6; i++) {
                const bx = 100 + Math.random() * 500;
                const by = Math.random() * (MAP_HEIGHT - 150) + 50;
                const distToCenter = Math.sqrt((bx - MAP_WIDTH/2) ** 2 + (by - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 250 && canPlace(bx, by, 60, 50)) {
                    obstacles.push(new Obstacle(bx, by, 60, 50, 'wooden_building'));
                }
            }
        }
        
        // LEVEL 5: THE ARCTIC - ice patches that make you slide, snow
        function generateArcticMap(canPlace) {
            // ICE PATCHES - player slides across these!
            icePatches.push(new IcePatch(150, 150, 350, 250));
            icePatches.push(new IcePatch(MAP_WIDTH - 550, 300, 400, 300));
            icePatches.push(new IcePatch(300, MAP_HEIGHT - 450, 450, 300));
            icePatches.push(new IcePatch(MAP_WIDTH - 400, MAP_HEIGHT - 350, 300, 250));
            icePatches.push(new IcePatch(MAP_WIDTH/2 - 150, MAP_HEIGHT/2 + 200, 300, 200));
            
            // Frozen lakes (water you can't cross)
            obstacles.push(new Obstacle(600, 100, 200, 150, 'river'));
            obstacles.push(new Obstacle(100, 800, 250, 180, 'river'));
            
            // Snow-covered buildings (research stations)
            for (let i = 0; i < 10; i++) {
                const bx = Math.random() * (MAP_WIDTH - 150) + 50;
                const by = Math.random() * (MAP_HEIGHT - 150) + 50;
                const distToCenter = Math.sqrt((bx - MAP_WIDTH/2) ** 2 + (by - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 250 && canPlace(bx, by, 70, 60)) {
                    obstacles.push(new Obstacle(bx, by, 70, 60, 'building'));
                }
            }
            
            // Pine trees scattered around
            let treesPlaced = 0;
            let attempts = 0;
            while (treesPlaced < 25 && attempts < 150) {
                const tx = Math.random() * (MAP_WIDTH - 100) + 50;
                const ty = Math.random() * (MAP_HEIGHT - 100) + 50;
                const distToCenter = Math.sqrt((tx - MAP_WIDTH/2) ** 2 + (ty - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 200 && canPlace(tx, ty, 35, 50, 25)) {
                    obstacles.push(new Obstacle(tx, ty, 35, 50, 'tree'));
                    treesPlaced++;
                }
                attempts++;
            }
        }
        
        // LEVEL 6: THE VOLCANO - lava, dangerous terrain
        function generateVolcanoMap(canPlace) {
            const centerX = MAP_WIDTH / 2;
            const centerY = MAP_HEIGHT / 2;
            
            // LAVA FLOWING FROM LEFT SIDE - very visible!
            // Main lava river from the left edge
            obstacles.push(new Obstacle(0, centerY - 100, 400, 200, 'lava'));
            // Lava pool spreading into center
            obstacles.push(new Obstacle(350, centerY - 150, 200, 300, 'lava'));
            // Secondary lava stream from top-left
            obstacles.push(new Obstacle(0, 200, 250, 100, 'lava'));
            obstacles.push(new Obstacle(200, 250, 100, 200, 'lava'));
            // Lava from bottom-left
            obstacles.push(new Obstacle(0, MAP_HEIGHT - 300, 200, 100, 'lava'));
            obstacles.push(new Obstacle(150, MAP_HEIGHT - 350, 100, 150, 'lava'));
            
            // Volcano mountain on the left side (source of lava)
            obstacles.push(new Obstacle(50, centerY - 200, 150, 400, 'mountain'));
            
            // Rocky platforms (safe zones) on the RIGHT side - away from lava!
            obstacles.push(new Obstacle(MAP_WIDTH - 300, 100, 200, 160, 'raised'));
            obstacles.push(new Obstacle(MAP_WIDTH - 330, 160, 80, 50, 'ramp', 'left'));
            
            obstacles.push(new Obstacle(MAP_WIDTH - 300, MAP_HEIGHT - 260, 200, 160, 'raised'));
            obstacles.push(new Obstacle(MAP_WIDTH - 330, MAP_HEIGHT - 200, 80, 50, 'ramp', 'left'));
            
            obstacles.push(new Obstacle(MAP_WIDTH - 300, centerY - 80, 200, 160, 'raised'));
            obstacles.push(new Obstacle(MAP_WIDTH - 330, centerY - 20, 80, 50, 'ramp', 'left'));
            
            // Scattered volcanic rocks
            for (let i = 0; i < 12; i++) {
                const bx = 600 + Math.random() * 600;
                const by = Math.random() * (MAP_HEIGHT - 150) + 50;
                if (canPlace(bx, by, 60, 60)) {
                    obstacles.push(new Obstacle(bx, by, 50 + Math.random() * 50, 50 + Math.random() * 50, 'mountain'));
                }
            }
        }
        
        // LEVEL 7: THE AIRPORT - runways with markings, attacking planes, faster gameplay
        function generateAirportMap(canPlace) {
            levelSpeedMultiplier = 1.5; // Everything is faster!
            
            // MAIN RUNWAYS - much bigger and more of them!
            // Primary horizontal runway (huge)
            obstacles.push(new Obstacle(50, MAP_HEIGHT/2 - 80, MAP_WIDTH - 100, 160, 'runway'));
            // Primary vertical runway (huge)
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 80, 50, 160, MAP_HEIGHT - 100, 'runway'));
            
            // Secondary runways (diagonal feel with horizontal/vertical)
            obstacles.push(new Obstacle(100, 250, MAP_WIDTH - 200, 100, 'runway'));
            obstacles.push(new Obstacle(100, MAP_HEIGHT - 350, MAP_WIDTH - 200, 100, 'runway'));
            obstacles.push(new Obstacle(250, 100, 100, MAP_HEIGHT - 200, 'runway'));
            obstacles.push(new Obstacle(MAP_WIDTH - 350, 100, 100, MAP_HEIGHT - 200, 'runway'));
            
            // Taxiways connecting runways
            obstacles.push(new Obstacle(400, 150, 300, 60, 'runway'));
            obstacles.push(new Obstacle(MAP_WIDTH - 700, MAP_HEIGHT - 210, 300, 60, 'runway'));
            obstacles.push(new Obstacle(150, 500, 60, 300, 'runway'));
            obstacles.push(new Obstacle(MAP_WIDTH - 210, 500, 60, 300, 'runway'));
            
            // Terminal buildings (smaller to make room for runways)
            obstacles.push(new Obstacle(50, 50, 150, 120, 'building'));
            obstacles.push(new Obstacle(MAP_WIDTH - 200, 50, 150, 120, 'building'));
            obstacles.push(new Obstacle(50, MAP_HEIGHT - 170, 150, 120, 'building'));
            obstacles.push(new Obstacle(MAP_WIDTH - 200, MAP_HEIGHT - 170, 150, 120, 'building'));
            
            // Control tower
            obstacles.push(new Obstacle(MAP_WIDTH/2 + 200, 150, 50, 80, 'building'));
            
            // Flying planes that ATTACK!
            for (let i = 0; i < 8; i++) {
                planes.push(new Plane());
            }
        }
        
        // LEVEL 8: THE MOON - craters, moon bases, astronauts
        function generateMoonMap(canPlace) {
            // Craters everywhere
            for (let i = 0; i < 15; i++) {
                const cx = Math.random() * (MAP_WIDTH - 150) + 50;
                const cy = Math.random() * (MAP_HEIGHT - 150) + 50;
                const size = 60 + Math.random() * 80;
                const distToCenter = Math.sqrt((cx - MAP_WIDTH/2) ** 2 + (cy - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 200 && canPlace(cx, cy, size, size, 20)) {
                    obstacles.push(new Obstacle(cx, cy, size, size, 'crater'));
                }
            }
            
            // Moon bases
            for (let i = 0; i < 5; i++) {
                const bx = Math.random() * (MAP_WIDTH - 150) + 50;
                const by = Math.random() * (MAP_HEIGHT - 150) + 50;
                const distToCenter = Math.sqrt((bx - MAP_WIDTH/2) ** 2 + (by - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 250 && canPlace(bx, by, 100, 60)) {
                    obstacles.push(new Obstacle(bx, by, 100, 60, 'moon_base'));
                }
            }
            
            // Astronauts wandering around
            for (let i = 0; i < 6; i++) {
                const ax = Math.random() * (MAP_WIDTH - 200) + 100;
                const ay = Math.random() * (MAP_HEIGHT - 200) + 100;
                astronauts.push(new Astronaut(ax, ay));
            }
            
            // Raised lunar highlands
            obstacles.push(new Obstacle(100, 100, 300, 200, 'raised'));
            obstacles.push(new Obstacle(370, 150, 80, 100, 'ramp', 'right'));
            obstacles.push(new Obstacle(MAP_WIDTH - 400, MAP_HEIGHT - 300, 300, 200, 'raised'));
            obstacles.push(new Obstacle(MAP_WIDTH - 430, MAP_HEIGHT - 250, 80, 100, 'ramp', 'left'));
        }
        
        // LEVEL 9: DEEP SPACE - asteroids, stars, floating platforms
        function generateSpaceMap(canPlace) {
            // Floating asteroid platforms
            for (let i = 0; i < 20; i++) {
                const ax = Math.random() * (MAP_WIDTH - 150) + 50;
                const ay = Math.random() * (MAP_HEIGHT - 150) + 50;
                const size = 50 + Math.random() * 100;
                const distToCenter = Math.sqrt((ax - MAP_WIDTH/2) ** 2 + (ay - MAP_HEIGHT/2) ** 2);
                if (distToCenter > 200 && canPlace(ax, ay, size, size, 30)) {
                    obstacles.push(new Obstacle(ax, ay, size, size * 0.7, 'asteroid'));
                }
            }
            
            // Space station modules (act as buildings)
            obstacles.push(new Obstacle(200, 200, 150, 100, 'building'));
            obstacles.push(new Obstacle(MAP_WIDTH - 350, 200, 150, 100, 'building'));
            obstacles.push(new Obstacle(200, MAP_HEIGHT - 300, 150, 100, 'building'));
            obstacles.push(new Obstacle(MAP_WIDTH - 350, MAP_HEIGHT - 300, 150, 100, 'building'));
            
            // Central space platform
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 150, MAP_HEIGHT/2 - 150, 300, 300, 'raised'));
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 40, MAP_HEIGHT/2 - 210, 80, 80, 'ramp', 'down'));
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 40, MAP_HEIGHT/2 + 130, 80, 80, 'ramp', 'up'));
            obstacles.push(new Obstacle(MAP_WIDTH/2 - 210, MAP_HEIGHT/2 - 40, 80, 80, 'ramp', 'right'));
            obstacles.push(new Obstacle(MAP_WIDTH/2 + 130, MAP_HEIGHT/2 - 40, 80, 80, 'ramp', 'left'));
            
            // Star clusters (decorative, non-blocking)
            for (let i = 0; i < 30; i++) {
                const sx = Math.random() * MAP_WIDTH;
                const sy = Math.random() * MAP_HEIGHT;
                obstacles.push(new Obstacle(sx, sy, 30, 30, 'star_cluster'));
            }
        }

        function clearSpawnArea() {
            const centerX = MAP_WIDTH / 2;
            const centerY = MAP_HEIGHT / 2;
            const clearRadius = 150;
            
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                if (obs.x < 0 || obs.y < 0 || obs.x >= MAP_WIDTH || obs.y >= MAP_HEIGHT) continue;
                if (obs.type === 'raised' || obs.type === 'ramp') continue;
                
                const obsLeft = obs.x;
                const obsRight = obs.x + obs.width;
                const obsTop = obs.y;
                const obsBottom = obs.y + obs.height;
                
                const spawnLeft = centerX - clearRadius;
                const spawnRight = centerX + clearRadius;
                const spawnTop = centerY - clearRadius;
                const spawnBottom = centerY + clearRadius;
                
                if (obsRight > spawnLeft && obsLeft < spawnRight && 
                    obsBottom > spawnTop && obsTop < spawnBottom) {
                    obstacles.splice(i, 1);
                }
            }
        }

        // ============================================
        // MAIN GAME LOGIC
        // ============================================
        function spawnLevelEnemies() {
            // No enemies in battle royale mode - players fight each other!
            if (isMultiplayer && multiplayerMode === 'battle') {
                return;
            }
            
            const numEnemies = enemiesPerLevel[Math.min(currentLevel - 1, enemiesPerLevel.length - 1)];
            for (let i = 0; i < numEnemies; i++) {
                const enemy = new Enemy();
                // Beach level: all enemies are hovercrafts!
                if (currentLevel === 4) {
                    enemy.isHovercraft = true;
                    enemy.color = '#00AAAA'; // Teal hovercraft color
                }
                enemies.push(enemy);
            }
            boss = new Boss(currentLevel);
        }

        function updateGame() {
            if (!gameRunning || showingLevelIntro || gamePaused) return;
            
            // Level transition countdown - player can still move and grab powerups
            if (levelTransitionActive) {
                levelTransitionCountdown--;
                if (levelTransitionCountdown <= 0) {
                    levelTransitionActive = false;
                    proceedToNextLevel();
                    return;
                }
                // During countdown, still update player movement, magnet, and powerup collection
                updatePlayer();
                
                // Magnet still works during countdown
                if (player.magnetRange > 0) {
                    powerups.forEach(powerup => {
                        const dx = player.x - powerup.x;
                        const dy = player.y - powerup.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < player.magnetRange && dist > 10) {
                            const pullSpeed = 3;
                            powerup.x += (dx / dist) * pullSpeed;
                            powerup.y += (dy / dist) * pullSpeed;
                        }
                    });
                }
                
                // Powerup collection during countdown
                collectPowerups();
                
                // Round health to integer
                player.health = Math.round(player.health);
                updateCamera();
                return;
            }
            
            // Regen effect (permanent upgrade)
            if (player.regenRate > 0 && player.health < player.maxHealth) {
                player.health = Math.min(player.health + player.regenRate / 60, player.maxHealth); // Per frame
            }
            
            // Magnet effect - attract nearby powerups
            if (player.magnetRange > 0) {
                powerups.forEach(powerup => {
                    const dx = player.x - powerup.x;
                    const dy = player.y - powerup.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < player.magnetRange && dist > 10) {
                        const pullSpeed = 3;
                        powerup.x += (dx / dist) * pullSpeed;
                        powerup.y += (dy / dist) * pullSpeed;
                    }
                });
            }
            
            updatePlayer();
            
            bullets.forEach((bullet, index) => {
                bullet.update();
                if (bullet.isOffScreen()) {
                    bullets.splice(index, 1);
                    return;
                }
                enemies.forEach((enemy, enemyIndex) => {
                    if (checkBulletCollision(bullet, enemy)) {
                        // Ally bullets do 15 damage, player bullets do 25-50
                        const damage = bullet.owner === 'ally' ? 15 : (player.damageBoost ? 50 : 25);
                        enemy.health -= damage;
                        bullets.splice(index, 1);
                        if (enemy.health <= 0) {
                            // Higher drop rate, chance for permanent powerups
                            if (Math.random() < 0.45) {
                                const tempTypes = ['rapidfire', 'health', 'speed', 'shield', 'damage', 'ghost', 'multishot', 'magnet'];
                                const permTypes = ['maxhealth', 'armor', 'bulletspeed', 'regen', 'ally'];
                                // 15% of drops are permanent
                                if (Math.random() < 0.15) {
                                    powerups.push(new Powerup(enemy.x, enemy.y, permTypes[Math.floor(Math.random() * permTypes.length)]));
                                } else {
                                    powerups.push(new Powerup(enemy.x, enemy.y, tempTypes[Math.floor(Math.random() * tempTypes.length)]));
                                }
                            }
                            enemies.splice(enemyIndex, 1);
                            score += 100;
                            updateUI();
                        }
                    }
                });
                if (boss && checkBulletCollision(bullet, boss)) {
                    // Ally bullets do 15 damage to boss too
                    const bossDamage = bullet.owner === 'ally' ? 15 : (player.damageBoost ? 50 : 25);
                    if (boss.takeDamage(bossDamage)) {
                        bullets.splice(index, 1);
                        if (boss.health <= 0) {
                            score += 500 + (currentLevel * 100);
                            
                            // In battle mode, boss death drops 2 ally powerups!
                            if (isMultiplayer && multiplayerMode === 'battle') {
                                for (let i = 0; i < 2; i++) {
                                    const angle = (i / 2) * Math.PI * 2;
                                    const dist = 50 + Math.random() * 30;
                                    powerups.push(new Powerup(
                                        boss.x + Math.cos(angle) * dist,
                                        boss.y + Math.sin(angle) * dist,
                                        'ally'
                                    ));
                                }
                                showPowerupPopup('üíÄ BOSS DEFEATED! 2 ALLY POWERUPS DROPPED!');
                            } else {
                                // Normal mode: Boss ALWAYS drops a permanent powerup!
                                const permTypes = ['maxhealth', 'armor', 'bulletspeed', 'regen', 'ally'];
                                powerups.push(new Powerup(boss.x, boss.y, permTypes[Math.floor(Math.random() * permTypes.length)]));
                                // Also drop 1-2 regular powerups
                                const tempTypes = ['rapidfire', 'health', 'speed', 'shield', 'damage', 'ghost', 'multishot'];
                                powerups.push(new Powerup(boss.x + 30, boss.y, tempTypes[Math.floor(Math.random() * tempTypes.length)]));
                                if (Math.random() < 0.5) {
                                    powerups.push(new Powerup(boss.x - 30, boss.y, tempTypes[Math.floor(Math.random() * tempTypes.length)]));
                                }
                            }
                            boss = null;
                            updateUI();
                        }
                    }
                }
            });
            
            if (enemies.length === 0 && boss === null && !levelTransitionActive && !(isMultiplayer && multiplayerMode === 'battle')) {
                startLevelTransition();
            }
            
            enemyBullets.forEach((bullet, index) => {
                bullet.update();
                if (bullet.isOffScreen()) {
                    enemyBullets.splice(index, 1);
                    return;
                }
                if (checkBulletCollision(bullet, player)) {
                    if (player.shieldActive) {
                        // Shield blocks bullet
                        enemyBullets.splice(index, 1);
                        return;
                    }
                    if (gameMode === 'hardcore') {
                        player.health = 0;
                    } else {
                        // Apply armor reduction (each level reduces damage by 2)
                        const armorReduction = player.armorLevel * 2;
                        const damage = Math.max(10 - armorReduction, 3); // Minimum 3 damage
                        player.health -= damage;
                    }
                    enemyBullets.splice(index, 1);
                    updateUI();
                    if (player.health <= 0) {
                        endGame();
                    }
                    return;
                }
                // Enemy bullets can hit ally tanks
                for (let i = allies.length - 1; i >= 0; i--) {
                    if (checkBulletCollision(bullet, allies[i])) {
                        allies[i].health -= 10;
                        enemyBullets.splice(index, 1);
                        return;
                    }
                }
            });
            
            enemies.forEach(enemy => {
                enemy.speed *= levelSpeedMultiplier;
                enemy.update();
                enemy.speed /= levelSpeedMultiplier;
            });
            if (boss) {
                boss.speed *= levelSpeedMultiplier;
                boss.update();
                boss.speed /= levelSpeedMultiplier;
            }
            
            // Update ally tanks
            allies.forEach(ally => ally.update());
            
            // Remove dead allies
            for (let i = allies.length - 1; i >= 0; i--) {
                if (allies[i].health <= 0) {
                    allies.splice(i, 1);
                }
            }
            
            // Update special level entities
            animals.forEach(animal => animal.update());
            planes.forEach(plane => plane.update());
            astronauts.forEach(astronaut => astronaut.update());
            dustParticles.forEach(dust => dust.update());
            fireParticles.forEach(fire => fire.update());
            conveyorBelts.forEach(belt => {
                belt.update();
                // Apply conveyor force to player
                if (!player.ghost) belt.applyForce(player);
            });
            
            // MOON LEVEL: Meteor showers!
            if (currentLevel === 8) {
                // Spawn new meteors randomly
                if (Math.random() < 0.02) { // ~1 meteor per 50 frames
                    meteors.push(new Meteor());
                }
                meteors.forEach(meteor => meteor.update());
            }
            
            // VOLCANO LEVEL: Lava slowly expands!
            if (currentLevel === 6) {
                lavaExpansionTimer++;
                if (lavaExpansionTimer % 60 === 0) { // Every second
                    obstacles.forEach(obs => {
                        if (obs.type === 'lava') {
                            // Expand lava in all directions
                            obs.x -= lavaExpansionRate;
                            obs.y -= lavaExpansionRate;
                            obs.width += lavaExpansionRate * 2;
                            obs.height += lavaExpansionRate * 2;
                        }
                    });
                }
            }
            
            // BATTLE ARENA: Check bullet collision with boss statues
            bullets.forEach((bullet, bulletIndex) => {
                bossStatues.forEach(statue => {
                    if (!statue.awakened) {
                        const bulletRect = { x: bullet.x - 5, y: bullet.y - 5, width: 10, height: 10 };
                        const statueRect = { x: statue.x - statue.width/2, y: statue.y - statue.height/2, width: statue.width, height: statue.height };
                        if (checkCollision(bulletRect, statueRect)) {
                            const damage = player.damageBoost ? 50 : 25;
                            statue.takeDamage(damage);
                            bullets.splice(bulletIndex, 1);
                        }
                    }
                });
            });
            
            // Check bullet collision with animals
            bullets.forEach((bullet, bulletIndex) => {
                animals.forEach((animal, animalIndex) => {
                    if (animal.alive) {
                        const dx = bullet.x - animal.x;
                        const dy = bullet.y - animal.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 30) {
                            animal.alive = false;
                            bullets.splice(bulletIndex, 1);
                            score += 25;
                        }
                    }
                });
            });
            
            upgrades.forEach((upgrade, index) => {
                if (!upgrade.collected) {
                    const dx = player.x - upgrade.x;
                    const dy = player.y - upgrade.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 50) {
                        upgrade.collected = true;
                        if (upgrade.type === 'hovercraft') {
                            player.isHovercraft = true;
                            player.color = '#00FFFF';
                            score += 500;
                        }
                        upgrades.splice(index, 1);
                        updateUI();
                    }
                }
            });
            
            collectPowerups();
            
            // Check PvP collisions in battle mode
            checkPvPCollisions();
            
            // Always round health to integer
            player.health = Math.round(player.health);
            
            updateCamera();
        }
        
        function collectPowerups() {
            powerups.forEach((powerup, index) => {
                if (powerup.isExpired()) {
                    powerups.splice(index, 1);
                    return;
                }
                const dx = player.x - powerup.x;
                const dy = player.y - powerup.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 40) {
                    if (powerup.type === 'rapidfire') {
                        player.shootCooldown = 100;
                        showPowerupPopup('‚ö° RAPID FIRE - Shoot faster!');
                        addActivePowerup('RAPID FIRE', '‚ö°', '#ffff00', 900);
                        setTimeout(() => { player.shootCooldown = player.baseShootCooldown; }, 15000);
                    } else if (powerup.type === 'health') {
                        player.health = player.health + 30; // No cap - health can exceed maxHealth!
                        showPowerupPopup('‚ù§Ô∏è HEALTH - +30 HP!');
                    } else if (powerup.type === 'speed') {
                        const originalSpeed = player.speed;
                        player.speed = gameMode === 'hardcore' ? 24 : 8;
                        showPowerupPopup('üöÄ SPEED - Move faster!');
                        addActivePowerup('SPEED', 'üöÄ', '#00ffff', 900);
                        setTimeout(() => { player.speed = originalSpeed; }, 15000);
                    } else if (powerup.type === 'shield') {
                        player.shieldActive = true;
                        player.color = '#0066ff';
                        showPowerupPopup('üõ°Ô∏è SHIELD - Invincible! (Blue tank)');
                        addActivePowerup('SHIELD', 'üõ°', '#0066ff', 600);
                        setTimeout(() => { player.shieldActive = false; player.color = '#00ff00'; }, 10000);
                    } else if (powerup.type === 'damage') {
                        player.damageBoost = true;
                        showPowerupPopup('üí• DAMAGE - Double damage!');
                        addActivePowerup('DAMAGE', 'üí•', '#ff00ff', 900);
                        setTimeout(() => { player.damageBoost = false; }, 15000);
                    } else if (powerup.type === 'ghost') {
                        player.ghost = true;
                        showPowerupPopup('üëª GHOST - Pass through walls!');
                        addActivePowerup('GHOST', 'üëª', '#aaaaaa', 600);
                        setTimeout(() => { player.ghost = false; }, 10000);
                    } else if (powerup.type === 'multishot') {
                        player.multishot = true;
                        showPowerupPopup('‚ú¶ MULTISHOT - Triple bullets!');
                        addActivePowerup('MULTI', '‚ú¶', '#ffff00', 900);
                        setTimeout(() => { player.multishot = false; }, 15000);
                    }
                    // PERMANENT POWERUPS
                    else if (powerup.type === 'maxhealth') {
                        player.maxHealth += 25;
                        player.health += 25;
                        addPermanentPowerup('+HP', '‚ô•', '#ff69b4');
                        showPowerupPopup('‚ô• MAX HEALTH +25 - PERMANENT!');
                    } else if (powerup.type === 'armor') {
                        player.armorLevel = Math.min(player.armorLevel + 1, 3);
                        addPermanentPowerup('ARM' + player.armorLevel, 'üî∞', '#b8860b');
                        showPowerupPopup('üî∞ ARMOR LV' + player.armorLevel + ' - Take less damage! PERMANENT!');
                    } else if (powerup.type === 'bulletspeed') {
                        player.bulletSpeedBonus += 3;
                        addPermanentPowerup('B.SPD', '¬ª', '#ff4444');
                        showPowerupPopup('¬ª BULLET SPEED +3 - PERMANENT!');
                    } else if (powerup.type === 'magnet') {
                        player.magnetRange = 150;
                        showPowerupPopup('üß≤ MAGNET - Attract powerups!');
                        addActivePowerup('MAGNET', 'üß≤', '#9932cc', 900);
                        setTimeout(() => { player.magnetRange = 0; }, 15000);
                    } else if (powerup.type === 'regen') {
                        player.regenRate += 0.5;
                        addPermanentPowerup('REGEN', '‚ôª', '#32cd32');
                        showPowerupPopup('‚ôª REGEN +0.5/sec - PERMANENT!');
                    } else if (powerup.type === 'ally') {
                        // Spawn a friendly tank!
                        const ally = new AllyTank(player.x + (Math.random() - 0.5) * 100, player.y + (Math.random() - 0.5) * 100);
                        allies.push(ally);
                        addPermanentPowerup('ALLY', 'üü¢', '#00ff00');
                        showPowerupPopup('üü¢ ALLY TANK - Fight alongside you! PERMANENT!');
                    }
                    powerups.splice(index, 1);
                    score += 50;
                    updateUI();
                }
            });
        }

        function drawGame() {
            const colors = themeColors[currentTheme];
            ctx.fillStyle = colors.ground;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars in space level
            if (currentLevel === 9) {
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 100; i++) {
                    const sx = (i * 137 + camera.x * 0.1) % canvas.width;
                    const sy = (i * 97 + camera.y * 0.1) % canvas.height;
                    ctx.beginPath();
                    ctx.arc(sx, sy, Math.random() * 1.5 + 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.strokeStyle = currentLevel === 9 ? 'rgba(100, 100, 150, 0.1)' : 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridStart = Math.floor(camera.x / 50) * 50;
            const gridStartY = Math.floor(camera.y / 50) * 50;
            
            updateActivePowerups();
            
            for (let x = gridStart; x < gridStart + canvas.width + 50; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x - camera.x, 0);
                ctx.lineTo(x - camera.x, canvas.height);
                ctx.stroke();
            }
            for (let y = gridStartY; y < gridStartY + canvas.height + 50; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y - camera.y);
                ctx.lineTo(canvas.width, y - camera.y);
                ctx.stroke();
            }
            
            // Draw moving water (beach level)
            movingWater.forEach(water => water.draw());
            
            // Draw conveyor belts (battle arena)
            conveyorBelts.forEach(belt => belt.draw());
            
            // Draw ice patches (arctic level)
            icePatches.forEach(ice => ice.draw());
            
            obstacles.forEach(obstacle => obstacle.draw());
            upgrades.forEach(upgrade => upgrade.draw());
            powerups.forEach(powerup => powerup.draw());
            
            // Draw boss statues (battle arena)
            bossStatues.forEach(statue => statue.draw());
            
            // Draw special entities
            animals.forEach(animal => animal.draw());
            astronauts.forEach(astronaut => astronaut.draw());
            planes.forEach(plane => plane.draw());
            
            // Draw dust particles (desert level) - on top of everything
            dustParticles.forEach(dust => dust.draw());
            
            // Draw fire particles (town level) - on top
            fireParticles.forEach(fire => fire.draw());
            
            // Draw meteors (moon level) - very top
            meteors.forEach(meteor => meteor.draw());
            
            bullets.forEach(bullet => bullet.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            enemies.forEach(enemy => enemy.draw());
            allies.forEach(ally => ally.draw());
            if (boss) boss.draw();
            drawPlayer();
            drawPlayer2(); // Multiplayer - draw second player
            drawUI();
            
            // Draw level transition countdown
            if (levelTransitionActive) {
                const secondsLeft = Math.ceil(levelTransitionCountdown / 60);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(canvas.width / 2 - 150, 80, 300, 80);
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL CLEAR!', canvas.width / 2, 115);
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 20px Arial';
                ctx.fillText(`Grab powerups! Next level in ${secondsLeft}...`, canvas.width / 2, 145);
            }
            
            // Draw pause overlay
            if (gamePaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 30);
                ctx.font = '24px Arial';
                ctx.fillStyle = '#aaaaaa';
                ctx.fillText('Press ENTER to resume', canvas.width / 2, canvas.height / 2 + 20);
            }
        }

        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        function startGame(mode = 'normal') {
            gameMode = mode;
            gameRunning = true;
            score = 0;
            currentLevel = 1;
            currentTheme = themes[0]; // 'town'
            
            bullets.length = 0;
            enemyBullets.length = 0;
            enemies.length = 0;
            powerups.length = 0;
            boss = null;
            
            generateMap();
            resetPlayer();
            findSafeSpawn();
            
            if (gameMode === 'hardcore') {
                player.speed = 15;
                player.color = '#ff4444';
            }
            
            showLevelIntro(1, currentTheme);
        }

        function startLevelTransition() {
            // Start 5 second countdown before next level
            levelTransitionActive = true;
            levelTransitionCountdown = 300; // 5 seconds at 60fps
            // Clear enemy bullets so player is safe
            enemyBullets.length = 0;
        }
        
        function proceedToNextLevel() {
            if (currentLevel >= MAX_LEVEL) {
                showVictory();
                return;
            }
            
            currentLevel++;
            score += 500;
            currentTheme = themes[currentLevel - 1]; // Direct mapping, no cycling
            
            // Clear everything properly
            bullets.length = 0;
            enemyBullets.length = 0;
            enemies.length = 0;
            powerups.length = 0;
            // Keep allies - they persist through levels!
            boss = null;
            
            // Regenerate the map for the new level!
            generateMap();
            
            // Reset player position and find safe spawn
            player.x = MAP_WIDTH / 2;
            player.y = MAP_HEIGHT / 2;
            player.elevated = false;
            findSafeSpawn();
            
            // Teleport allies to near player spawn
            allies.forEach((ally, i) => {
                ally.x = player.x + (Math.random() - 0.5) * 150;
                ally.y = player.y + (Math.random() - 0.5) * 150;
                ally.health = ally.maxHealth; // Heal allies on level transition
            });
            
            showLevelIntro(currentLevel, currentTheme);
        }
        
        function showVictory() {
            gameRunning = false;
            
            // Draw victory screen on canvas
            const colors = themeColors[currentTheme];
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 64px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üèÜ VICTORY! üèÜ', canvas.width / 2, canvas.height / 2 - 80);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px Arial';
            ctx.fillText('You conquered all 9 levels!', canvas.width / 2, canvas.height / 2 - 20);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 48px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
            
            if (gameMode === 'hardcore') {
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 28px Arial';
                ctx.fillText('üíÄ HARDCORE CHAMPION! üíÄ', canvas.width / 2, canvas.height / 2 + 100);
            }
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '20px Arial';
            ctx.fillText('Click anywhere to return to menu', canvas.width / 2, canvas.height / 2 + 160);
            
            // One-time click handler to return to menu
            const returnToMenu = () => {
                canvas.removeEventListener('click', returnToMenu);
                demoMode = true;
                activePowerups = [];
                gameLoopStarted = false;
                document.getElementById('startScreen').style.display = 'flex';
                initDemo();
            };
            setTimeout(() => {
                canvas.addEventListener('click', returnToMenu);
            }, 1000);
        }

        let gameLoopStarted = false;

        function showLevelIntro(level, theme) {
            showingLevelIntro = true;
            document.getElementById('levelIntroNumber').textContent = level;
            document.getElementById('levelIntroTheme').textContent = levelNames[level - 1];
            
            const introContent = document.getElementById('levelIntroContent');
            introContent.className = 'level-intro-content ' + (gameMode === 'test' ? 'normal' : gameMode);
            document.getElementById('levelIntro').style.display = 'flex';
            
            setTimeout(() => {
                document.getElementById('levelIntro').style.display = 'none';
                showingLevelIntro = false;
                spawnLevelEnemies();
                updateUI();
                if (!gameLoopStarted) {
                    gameLoopStarted = true;
                    gameLoop();
                }
            }, 2000);
        }

        function endGame() {
            gameRunning = false;
            demoMode = true;
            activePowerups = [];
            document.getElementById('startScreen').style.display = 'flex';
        }

        function beginGame(mode = 'normal') {
            document.getElementById('startScreen').style.display = 'none';
            demoMode = false;
            activePowerups = [];
            startGame(mode);
        }

        // ============================================
        // DEMO MODE
        // ============================================
        function initDemo() {
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.health = 100;
            player.elevated = false;
            player.color = '#00ff00';
            
            obstacles.length = 0;
            obstacles.push(new Obstacle(100, 100, 80, 80, 'building'));
            obstacles.push(new Obstacle(600, 100, 80, 80, 'building'));
            obstacles.push(new Obstacle(100, 420, 80, 80, 'building'));
            obstacles.push(new Obstacle(600, 420, 80, 80, 'building'));
            
            demoLoop();
        }

        function updateDemo() {
            let vx = 0;
            let vy = 0;
            if (keys['w'] || keys['arrowup']) vy = -1;
            if (keys['s'] || keys['arrowdown']) vy = 1;
            if (keys['a'] || keys['arrowleft']) vx = -1;
            if (keys['d'] || keys['arrowright']) vx = 1;
            if (vx !== 0 && vy !== 0) { vx *= 0.707; vy *= 0.707; }
            
            const testX = player.x + vx * player.speed;
            const testY = player.y + vy * player.speed;
            const playerRect = { x: testX - player.width / 2, y: testY - player.height / 2, width: player.width, height: player.height };
            
            let canMove = true;
            for (let obstacle of obstacles) {
                if (checkCollision(playerRect, obstacle)) { canMove = false; break; }
            }
            
            if (canMove) {
                player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, testX));
                player.y = Math.max(player.height / 2, Math.min(canvas.height - player.height / 2, testY));
            }
            player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        }

        function drawDemo() {
            ctx.fillStyle = themeColors[currentTheme].ground;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            
            const savedCameraX = camera.x;
            const savedCameraY = camera.y;
            camera.x = 0;
            camera.y = 0;
            obstacles.forEach(obstacle => obstacle.draw());
            camera.x = savedCameraX;
            camera.y = savedCameraY;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            ctx.fillStyle = player.color;
            ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
            ctx.fillStyle = '#00aa00';
            ctx.fillRect(0, -5, 25, 10);
            ctx.restore();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Try moving with WASD!', canvas.width / 2, canvas.height - 20);
        }

        function demoLoop() {
            if (!demoMode) return;
            updateDemo();
            drawDemo();
            requestAnimationFrame(demoLoop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        document.addEventListener('keydown', (e) => { 
            keys[e.key.toLowerCase()] = true;
            // Enter toggles pause (not in multiplayer)
            if (e.code === 'Enter' && gameRunning && !showingLevelIntro && !isMultiplayer) {
                gamePaused = !gamePaused;
                e.preventDefault();
            }
            // Space bar always fires
            if (e.code === 'Space' && gameRunning && !showingLevelIntro) {
                const now = Date.now();
                if (now - lastShotTime > player.shootCooldown) {
                    shoot();
                    lastShotTime = now;
                }
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('click', () => {
            if (!gameRunning) return;
            const now = Date.now();
            if (now - lastShotTime > player.shootCooldown) {
                shoot();
                lastShotTime = now;
            }
        });

        // ============================================
        // TEST MODE / LEVEL SELECT
        // ============================================
        const levelColors = [
            '#4CAF50', '#d4a574', '#00bcd4', '#228b22', '#90caf9', 
            '#ff5722', '#4CAF50', '#d4a574', '#00bcd4', '#228b22'
        ];

        function initLevelSelect() {
            const grid = document.getElementById('levelGrid');
            grid.innerHTML = '';
            
            // Add Battle Arena option first
            const arenaBtn = document.createElement('button');
            arenaBtn.className = 'level-btn';
            arenaBtn.style.background = 'linear-gradient(180deg, #f44336 0%, #b71c1c 100%)';
            arenaBtn.style.color = '#fff';
            arenaBtn.innerHTML = `<span class="level-num">‚öîÔ∏è</span><span class="level-theme">BATTLE ARENA</span>`;
            arenaBtn.onclick = () => startTestLevel(0); // 0 = battle arena
            grid.appendChild(arenaBtn);
            
            for (let i = 1; i <= 9; i++) {
                const theme = themes[i - 1];
                const color = themeColors[theme].ground;
                const displayName = levelNames[i - 1];
                
                const btn = document.createElement('button');
                btn.className = 'level-btn';
                btn.style.background = `linear-gradient(180deg, ${color} 0%, ${adjustColor(color, -30)} 100%)`;
                btn.style.color = theme === 'snow' ? '#333' : '#fff';
                btn.innerHTML = `<span class="level-num">${i}</span><span class="level-theme">${displayName}</span>`;
                btn.onclick = () => startTestLevel(i);
                grid.appendChild(btn);
            }
        }

        function adjustColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
            const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
            const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function showLevelSelect() {
            initLevelSelect();
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('levelSelectScreen').style.display = 'flex';
        }

        function hideLevelSelect() {
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        function startTestLevel(level) {
            document.getElementById('levelSelectScreen').style.display = 'none';
            demoMode = false;
            activePowerups = [];
            gameMode = 'test';
            gameRunning = true;
            score = 0;
            currentLevel = level === 0 ? 1 : level; // Use level 1 settings for arena
            currentTheme = level === 0 ? 'town' : themes[level - 1];
            
            // For battle arena, temporarily set multiplayer mode
            if (level === 0) {
                isMultiplayer = true;
                multiplayerMode = 'battle';
            }
            
            bullets.length = 0;
            enemyBullets.length = 0;
            enemies.length = 0;
            powerups.length = 0;
            boss = null;
            
            generateMap();
            resetPlayer();
            findSafeSpawn();
            
            showLevelIntro(level, currentTheme);
        }

        // ============================================
        // MULTIPLAYER FUNCTIONS
        // ============================================
        let myPlayerId = null;
        let otherPlayers = {};
        let playersRef = null;
        let multiplayerMode = 'coop'; // 'coop' or 'battle'
        let battlePowerupInterval = null; // For spawning powerups in battle mode
        
        function showMultiplayer() {
            if (!database) {
                alert('Multiplayer requires Firebase configuration. Please set up Firebase and update the config in the code.');
                return;
            }
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('multiplayerScreen').style.display = 'flex';
            document.getElementById('mpLobby').style.display = 'block';
            document.getElementById('mpConnecting').style.display = 'none';
            
            // Check how many players are online in each mode
            let coopCount = 0, battleCount = 0;
            database.ref('coop/players').once('value', (snapshot) => {
                const players = snapshot.val();
                coopCount = players ? Object.keys(players).length : 0;
                updatePlayerCounts();
            });
            database.ref('battle/players').once('value', (snapshot) => {
                const players = snapshot.val();
                battleCount = players ? Object.keys(players).length : 0;
                updatePlayerCounts();
            });
            
            function updatePlayerCounts() {
                document.getElementById('mpPlayerCount').textContent = 
                    'ü§ù Co-op: ' + coopCount + ' | ‚öîÔ∏è Battle: ' + battleCount;
            }
        }
        
        function hideMultiplayer() {
            document.getElementById('multiplayerScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            if (playersRef) {
                playersRef.off();
            }
            // Clean up battle royale lobby
            if (brLobbyRef) {
                brLobbyRef.off();
                if (myPlayerId && brCurrentLobby) {
                    database.ref('battleLobby' + brCurrentLobby + '/players/' + myPlayerId).remove();
                }
            }
            if (brGameRef) {
                brGameRef.off();
            }
            // Stop listening to lobby counts
            lobbyCountRefs.forEach(ref => ref.off());
            lobbyCountRefs = [];
            // Reset UI
            document.getElementById('mpLobby').style.display = 'block';
            document.getElementById('brLobby').style.display = 'none';
            document.getElementById('brJoinOrHost').style.display = 'block';
            document.getElementById('brWaitingRoom').style.display = 'none';
        }
        
        // ============================================
        // BATTLE ROYALE LOBBY FUNCTIONS
        // ============================================
        
        function selectIcon(element) {
            document.querySelectorAll('#iconSelection .tank-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            brSelectedIcon = element.dataset.icon;
        }
        
        function selectShape(element) {
            document.querySelectorAll('#shapeSelection .tank-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            brSelectedShape = element.dataset.shape;
        }
        
        function showBattleRoyaleLobby() {
            document.getElementById('mpLobby').style.display = 'none';
            document.getElementById('brLobby').style.display = 'block';
            document.getElementById('brJoinOrHost').style.display = 'block';
            document.getElementById('brWaitingRoom').style.display = 'none';
            
            // Pre-fill name if we have one saved
            const savedName = localStorage.getItem('brPlayerName');
            if (savedName) {
                document.getElementById('brPlayerName').value = savedName;
            }
            
            // Listen to player counts for all 3 lobbies
            for (let i = 1; i <= 3; i++) {
                const lobbyRef = database.ref('battleLobby' + i + '/players');
                lobbyRef.on('value', (snapshot) => {
                    const players = snapshot.val() || {};
                    const count = Object.keys(players).length;
                    const countElement = document.getElementById('lobby' + i + 'Count');
                    if (countElement) {
                        countElement.textContent = count + (count === 1 ? ' player' : ' players');
                    }
                });
                lobbyCountRefs.push(lobbyRef);
            }
        }
        
        function joinBattleLobby(lobbyNum) {
            brPlayerName = document.getElementById('brPlayerName').value.trim() || 'Player';
            localStorage.setItem('brPlayerName', brPlayerName);
            
            brCurrentLobby = lobbyNum;
            myPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Set current time to ignore old game starts
            brGameStartTime = Date.now();
            
            // Add myself to the selected lobby
            const myRef = database.ref('battleLobby' + lobbyNum + '/players/' + myPlayerId);
            myRef.set({
                name: brPlayerName,
                icon: brSelectedIcon,
                shape: brSelectedShape,
                wins: brWins,
                joinedAt: Date.now()
            });
            myRef.onDisconnect().remove();
            
            showBattleWaitingRoom();
        }
        
        function showBattleWaitingRoom() {
            document.getElementById('brJoinOrHost').style.display = 'none';
            document.getElementById('brWaitingRoom').style.display = 'block';
            
            // Update lobby title
            const lobbyTitles = ['üéÆ Lobby 1', 'üéÆ Lobby 2', 'üéÆ Lobby 3'];
            document.getElementById('currentLobbyTitle').textContent = lobbyTitles[brCurrentLobby - 1];
            
            // Stop listening to lobby counts
            lobbyCountRefs.forEach(ref => ref.off());
            lobbyCountRefs = [];
            
            // Listen for players in the selected lobby
            brLobbyRef = database.ref('battleLobby' + brCurrentLobby + '/players');
            brLobbyRef.on('value', (snapshot) => {
                brLobbyPlayers = snapshot.val() || {};
                updateBattleLobbyUI();
            });
            
            // Listen for game start
            brGameRef = database.ref('battleLobby' + brCurrentLobby + '/gameStart');
            brGameRef.on('value', (snapshot) => {
                const startTime = snapshot.val();
                if (startTime && startTime > brGameStartTime) {
                    brGameStartTime = startTime;
                    launchBattleRoyale();
                }
            });
        }
        
        function updateBattleLobbyUI() {
            const container = document.getElementById('brPlayersContainer');
            container.innerHTML = '';
            
            const playerCount = Object.keys(brLobbyPlayers).length;
            
            // Shape symbols map
            const shapeSymbols = {
                'triangle': '‚ñ≤',
                'square': '‚ñ†',
                'pentagon': '‚¨ü',
                'hexagon': '‚¨¢',
                'circle': '‚óè',
                'diamond': '‚óÜ'
            };
            
            // Sort players by join time
            const sortedPlayers = Object.entries(brLobbyPlayers).sort((a, b) => {
                return a[1].joinedAt - b[1].joinedAt;
            });
            
            sortedPlayers.forEach(([id, player]) => {
                const div = document.createElement('div');
                div.className = 'player-entry';
                
                const wins = player.wins || 0;
                let winsDisplay;
                if (wins === 0) {
                    winsDisplay = '';
                } else if (wins <= 3) {
                    winsDisplay = 'üèÜ'.repeat(wins);
                } else {
                    winsDisplay = `üèÜ x${wins}`;
                }
                
                const youBadge = id === myPlayerId ? ' <span class="host-badge">YOU</span>' : '';
                const shapeSymbol = shapeSymbols[player.shape] || '‚ñ≤';
                const playerIcon = player.icon || player.tank || 'üéñÔ∏è';
                
                div.innerHTML = `
                    <span class="tank-icon">${playerIcon} ${shapeSymbol}</span>
                    <span class="player-name">${player.name}${youBadge}</span>
                    <span class="player-badges">${winsDisplay}</span>
                `;
                container.appendChild(div);
            });
            
            // Enable/disable begin button - any player can start when 2+ players
            const beginBtn = document.getElementById('brBeginBtn');
            if (beginBtn) {
                beginBtn.disabled = playerCount < 2;
            }
        }
        
        function startBattleRoyale() {
            // Any player can start when 2+ players
            const playerCount = Object.keys(brLobbyPlayers).length;
            if (playerCount < 2) return;
            // Signal all players to start
            database.ref('battleLobby' + brCurrentLobby + '/gameStart').set(Date.now());
        }
        
        function launchBattleRoyale() {
            document.getElementById('multiplayerScreen').style.display = 'none';
            document.getElementById('player2Indicator').style.display = 'block';
            document.getElementById('player2Indicator').textContent = '‚öîÔ∏è BATTLE';
            document.getElementById('player2Indicator').style.background = 'rgba(200, 0, 0, 0.7)';
            
            // Store initial player count before removing from lobby
            brInitialPlayerCount = Object.keys(brLobbyPlayers).length;
            
            // Remove from lobby while in game
            if (myPlayerId) {
                database.ref('battleLobby' + brCurrentLobby + '/players/' + myPlayerId).remove();
            }
            
            isMultiplayer = true;
            multiplayerMode = 'battle';
            
            demoMode = false;
            activePowerups = [];
            gameMode = 'normal';
            gameRunning = true;
            score = 0;
            battleKills = 0;
            battleHits = 0;  // Reset hit counter
            battleLives = 2; // Everyone starts with 2 lives
            isEliminated = false; // Reset ghost mode
            currentLevel = 1;
            currentTheme = themes[0];
            
            bullets.length = 0;
            enemyBullets.length = 0;
            enemies.length = 0;
            powerups.length = 0;
            boss = null;
            
            generateMap();
            resetPlayer();
            
            // Random color for this player
            const colors = ['#00ff00', '#0088ff', '#ff8800', '#ff00ff', '#00ffff', '#ffff00'];
            player.color = colors[Math.floor(Math.random() * colors.length)];
            findSafeSpawn();
            
            // Add to battle players path with our info
            const myPlayerRef = database.ref('battle/players/' + myPlayerId);
            myPlayerRef.set({
                x: player.x,
                y: player.y,
                angle: 0,
                health: 100,
                lives: 2,
                hits: 0,
                color: player.color,
                name: brPlayerName,
                icon: brSelectedIcon,
                shape: brSelectedShape,
                gameStart: brGameStartTime,
                lastUpdate: Date.now()
            });
            myPlayerRef.onDisconnect().remove();
            
            // Start syncing
            syncInterval = setInterval(syncMyPosition, 50);
            
            // Listen for other players from same game session
            playersRef = database.ref('battle/players');
            playersRef.on('value', (snapshot) => {
                const players = snapshot.val() || {};
                otherPlayers = {};
                let onlineCount = 0;
                for (const id in players) {
                    if (id !== myPlayerId && players[id].gameStart === brGameStartTime) {
                        otherPlayers[id] = players[id];
                        onlineCount++;
                    }
                }
                document.getElementById('player2Indicator').textContent = '‚öîÔ∏è ' + (onlineCount + 1) + ' players';
                
                // Check for winner - if only us left and game has been running for at least 3 seconds
                if (onlineCount === 0 && gameRunning && brInitialPlayerCount > 1 && Date.now() - brGameStartTime > 3000) {
                    declareWinner(myPlayerId, brPlayerName, brSelectedIcon, brSelectedShape);
                }
            });
            
            // Listen for hits and kills
            listenForHits();
            listenForKills();
            
            // Spawn powerups every 8 seconds in battle mode
            if (battlePowerupInterval) clearInterval(battlePowerupInterval);
            battlePowerupInterval = setInterval(() => {
                if (!gameRunning || !isMultiplayer || multiplayerMode !== 'battle') {
                    clearInterval(battlePowerupInterval);
                    return;
                }
                // Spawn a random powerup at random location
                const px = Math.random() * (MAP_WIDTH - 200) + 100;
                const py = Math.random() * (MAP_HEIGHT - 200) + 100;
                const allTypes = ['rapid', 'shield', 'speed', 'damage', 'homing', 'health', 'ally', 'hovercraft'];
                const type = allTypes[Math.floor(Math.random() * allTypes.length)];
                powerups.push(new Powerup(px, py, type));
            }, 8000);
            
            // Listen for winner announcement
            database.ref('battleLobby/winner').on('value', (snapshot) => {
                const winner = snapshot.val();
                if (winner && winner.gameStart === brGameStartTime && winner.id !== myPlayerId) {
                    // Add our own hits to the leaderboard if not already there
                    const leaderboard = winner.leaderboard || {};
                    if (!leaderboard[myPlayerId]) {
                        leaderboard[myPlayerId] = {
                            name: brPlayerName,
                            hits: battleHits
                        };
                    }
                    showEndScreen(winner.name, winner.icon, winner.shape, false, leaderboard);
                }
            });
            
            // Start game immediately
            spawnLevelEnemies();
            gameLoop();
        }
        
        function declareWinner(winnerId, winnerName, winnerIcon, winnerShape) {
            if (!gameRunning) return;
            gameRunning = false;
            
            // Fetch final hits from eliminated players FIRST, then build complete leaderboard
            database.ref('battle/finalHits').once('value', (snapshot) => {
                const finalHits = snapshot.val() || {};
                const leaderboardData = {};
                
                // Add hits from eliminated players
                for (const pid in finalHits) {
                    const p = finalHits[pid];
                    if (p.gameStart === brGameStartTime) {
                        leaderboardData[pid] = {
                            name: p.name || 'Player',
                            hits: p.hits || 0
                        };
                    }
                }
                
                // Add hits from other active players we tracked (shouldn't be any if we're the winner)
                for (const pid in otherPlayers) {
                    leaderboardData[pid] = {
                        name: otherPlayers[pid].name || 'Player',
                        hits: otherPlayers[pid].hits || 0
                    };
                }
                
                // Add our hits (the winner)
                leaderboardData[myPlayerId] = {
                    name: brPlayerName,
                    hits: battleHits
                };
                
                // Clean up finalHits for this game
                for (const pid in finalHits) {
                    if (finalHits[pid].gameStart === brGameStartTime) {
                        database.ref('battle/finalHits/' + pid).remove();
                    }
                }
                
                // Announce winner to all with COMPLETE leaderboard
                database.ref('battleLobby/winner').set({
                    id: winnerId,
                    name: winnerName,
                    icon: winnerIcon,
                    shape: winnerShape,
                    gameStart: brGameStartTime,
                    leaderboard: leaderboardData
                });
                
                // Increment wins for winner (session only)
                brWins++;
                
                // Show end screen with complete leaderboard
                showEndScreen(winnerName, winnerIcon, winnerShape, true, leaderboardData);
            });
        }
        
        function updateLeaderboardDisplay(leaderboardData) {
            const leaderboardDiv = document.getElementById('hitsLeaderboard');
            if (!leaderboardDiv) return;
            
            if (leaderboardData && Object.keys(leaderboardData).length > 0) {
                const sorted = Object.entries(leaderboardData).sort((a, b) => (b[1].hits || 0) - (a[1].hits || 0));
                let html = '';
                sorted.forEach(([pid, data], index) => {
                    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                    const isYou = pid === myPlayerId ? ' (You)' : '';
                    html += `<div style="padding: 5px; background: ${index % 2 === 0 ? '#333' : '#444'}; border-radius: 4px; margin: 2px 0;">${medal} ${data.name}${isYou}: <strong>${data.hits || 0} hits</strong></div>`;
                });
                leaderboardDiv.innerHTML = html;
            }
        }
        
        function showEndScreen(winnerName, icon, shape, isMe, leaderboardData) {
            const shapeSymbols = {
                'triangle': '‚ñ≤',
                'square': '‚ñ†',
                'pentagon': '‚¨ü',
                'hexagon': '‚¨¢',
                'circle': '‚óè',
                'diamond': '‚óÜ'
            };
            gameRunning = false;
            document.getElementById('endScreen').style.display = 'flex';
            
            // Show winner section only for the winner
            const winnerSection = document.getElementById('endWinnerSection');
            const loserSection = document.getElementById('endLoserSection');
            
            if (isMe) {
                winnerSection.style.display = 'block';
                loserSection.style.display = 'none';
                document.getElementById('winnerName').textContent = winnerName;
                document.getElementById('winnerTank').textContent = (icon || 'üéñÔ∏è') + ' ' + (shapeSymbols[shape] || '‚ñ≤');
            } else {
                winnerSection.style.display = 'none';
                loserSection.style.display = 'block';
                document.getElementById('eliminatedWinner').textContent = winnerName;
            }
            
            // Build hits leaderboard
            const leaderboardDiv = document.getElementById('hitsLeaderboard');
            if (leaderboardData && Object.keys(leaderboardData).length > 0) {
                // Sort by hits descending
                const sorted = Object.entries(leaderboardData).sort((a, b) => (b[1].hits || 0) - (a[1].hits || 0));
                let html = '';
                sorted.forEach(([pid, data], index) => {
                    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                    const isYou = pid === myPlayerId ? ' (You)' : '';
                    html += `<div style="padding: 5px; background: ${index % 2 === 0 ? '#333' : '#444'}; border-radius: 4px; margin: 2px 0;">${medal} ${data.name}${isYou}: <strong>${data.hits || 0} hits</strong></div>`;
                });
                leaderboardDiv.innerHTML = html;
            } else {
                leaderboardDiv.innerHTML = '<div style="color: #888;">No hit data available</div>';
            }
        }
        
        function returnToLobby() {
            document.getElementById('endScreen').style.display = 'none';
            document.getElementById('player2Indicator').style.display = 'none';
            
            // Stop game sync
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }
            
            // Remove from battle players
            if (myPlayerId) {
                database.ref('battle/players/' + myPlayerId).remove();
            }
            
            // Re-add to lobby
            if (myPlayerId && brCurrentLobby) {
                const myRef = database.ref('battleLobby' + brCurrentLobby + '/players/' + myPlayerId);
                myRef.set({
                    name: brPlayerName,
                    icon: brSelectedIcon,
                    shape: brSelectedShape,
                    wins: brWins,
                    joinedAt: Date.now()
                });
                myRef.onDisconnect().remove();
            }
            
            // Show multiplayer screen with waiting room
            document.getElementById('multiplayerScreen').style.display = 'flex';
            document.getElementById('mpLobby').style.display = 'none';
            document.getElementById('brLobby').style.display = 'block';
            document.getElementById('brJoinOrHost').style.display = 'none';
            document.getElementById('brWaitingRoom').style.display = 'block';
            
            // Re-listen for players and game start
            showBattleWaitingRoom();
        }
        
        // Co-op multiplayer (unchanged from before)
        function joinMultiplayer(mode) {
            document.getElementById('mpLobby').style.display = 'none';
            document.getElementById('mpConnecting').style.display = 'block';
            
            isMultiplayer = true;
            multiplayerMode = mode;
            
            myPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            const colors = ['#00ff00', '#0088ff', '#ff8800', '#ff00ff', '#00ffff', '#ffff00'];
            const myColor = colors[Math.floor(Math.random() * colors.length)];
            
            const gamePath = 'coop/players/';
            const myPlayerRef = database.ref(gamePath + myPlayerId);
            myPlayerRef.set({
                x: MAP_WIDTH / 2 + (Math.random() - 0.5) * 200,
                y: MAP_HEIGHT / 2 + (Math.random() - 0.5) * 200,
                angle: 0,
                health: 100,
                color: myColor,
                lastUpdate: Date.now()
            });
            
            myPlayerRef.onDisconnect().remove();
            
            setTimeout(() => {
                startMultiplayerGame(myColor, mode);
            }, 500);
        }
        
        function startMultiplayerGame(myColor, mode) {
            document.getElementById('multiplayerScreen').style.display = 'none';
            document.getElementById('player2Indicator').style.display = 'block';
            
            if (mode === 'battle') {
                document.getElementById('player2Indicator').textContent = '‚öîÔ∏è BATTLE';
                document.getElementById('player2Indicator').style.background = 'rgba(200, 0, 0, 0.7)';
            } else {
                document.getElementById('player2Indicator').textContent = 'ü§ù CO-OP';
                document.getElementById('player2Indicator').style.background = 'rgba(0, 200, 0, 0.7)';
            }
            
            demoMode = false;
            activePowerups = [];
            gameMode = 'normal';
            gameRunning = true;
            score = 0;
            battleKills = 0;
            currentLevel = 1;
            currentTheme = themes[0];
            
            bullets.length = 0;
            enemyBullets.length = 0;
            enemies.length = 0;
            powerups.length = 0;
            boss = null;
            
            generateMap();
            resetPlayer();
            player.color = myColor;
            findSafeSpawn();
            
            // Start syncing my position
            syncInterval = setInterval(syncMyPosition, 50);
            
            // Listen for other players
            const gamePath = mode === 'battle' ? 'battle/players' : 'coop/players';
            playersRef = database.ref(gamePath);
            playersRef.on('value', (snapshot) => {
                const players = snapshot.val() || {};
                otherPlayers = {};
                let onlineCount = 0;
                
                for (const id in players) {
                    if (id !== myPlayerId) {
                        otherPlayers[id] = players[id];
                    }
                    onlineCount++;
                }
                
                const modeIcon = mode === 'battle' ? '‚öîÔ∏è' : 'ü§ù';
                document.getElementById('player2Indicator').textContent = modeIcon + ' ' + onlineCount + ' online';
            });
            
            // In battle mode, listen for hits on us
            if (mode === 'battle') {
                listenForHits();
                listenForKills();
                // No intro countdown in battle mode - start immediately
                spawnLevelEnemies();
                gameLoop();
            } else {
                showLevelIntro(1, currentTheme);
            }
        }
        
        function syncMyPosition() {
            if (!myPlayerId || !gameRunning) return;
            const gamePath = multiplayerMode === 'battle' ? 'battle/players/' : 'coop/players/';
            database.ref(gamePath + myPlayerId).update({
                x: player.x,
                y: player.y,
                angle: player.angle,
                health: player.health,
                lives: battleLives,
                hits: battleHits,
                lastUpdate: Date.now()
            });
        }
        
        function drawPlayer2() {
            if (!isMultiplayer) return;
            
            // Draw all other players
            for (const id in otherPlayers) {
                const other = otherPlayers[id];
                
                const screenX = other.x - camera.x;
                const screenY = other.y - camera.y;
                
                // Only draw if on screen
                if (screenX < -50 || screenX > canvas.width + 50 || screenY < -50 || screenY > canvas.height + 50) continue;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(other.angle || 0);
                
                // Tank body - draw shape based on player's selected shape
                ctx.fillStyle = other.color || '#0088ff';
                drawTankShape(other.shape || 'square', player.width, player.height);
                
                // Barrel
                const darkerColor = adjustColor(other.color || '#0088ff', -50);
                ctx.fillStyle = darkerColor;
                ctx.fillRect(0, -4, 25, 8);
                
                ctx.restore();
                
                // Health bar
                const healthWidth = 40;
                const healthHeight = 5;
                const healthPercent = (other.health || 100) / 100;
                ctx.fillStyle = '#000';
                ctx.fillRect(screenX - healthWidth / 2, screenY - 30, healthWidth, healthHeight);
                ctx.fillStyle = other.color || '#0088ff';
                ctx.fillRect(screenX - healthWidth / 2, screenY - 30, healthWidth * healthPercent, healthHeight);
                
                // In battle mode, show icon and name
                if (multiplayerMode === 'battle') {
                    // Draw icon and player name
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(other.icon || 'üéñÔ∏è', screenX, screenY - 50);
                    if (other.name) {
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = 'white';
                        ctx.fillText(other.name, screenX, screenY - 38);
                    }
                }
            }
        }
        
        // Check if our bullets hit other players (battle mode)
        function checkPvPCollisions() {
            if (!isMultiplayer || multiplayerMode !== 'battle') return;
            
            bullets.forEach((bullet, bulletIndex) => {
                if (bullet.owner !== 'player') return;
                
                for (const id in otherPlayers) {
                    const other = otherPlayers[id];
                    const dx = bullet.x - other.x;
                    const dy = bullet.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 25) { // Hit!
                        bullets.splice(bulletIndex, 1);
                        // Notify the hit player via Firebase
                        const gamePath = 'battle/hits/' + id;
                        database.ref(gamePath).push({
                            damage: 20,
                            from: myPlayerId,
                            timestamp: Date.now()
                        });
                        // Track our hits for leaderboard
                        battleHits++;
                        // Update hits count in Firebase
                        database.ref('battle/players/' + myPlayerId + '/hits').set(battleHits);
                        // Show hit effect
                        showPowerupPopup('üí• HIT!');
                        return;
                    }
                }
            });
        }
        
        // Listen for hits on us (battle mode)
        function listenForHits() {
            if (!isMultiplayer || multiplayerMode !== 'battle' || !myPlayerId) return;
            
            const hitsRef = database.ref('battle/hits/' + myPlayerId);
            hitsRef.on('child_added', (snapshot) => {
                const hit = snapshot.val();
                if (hit && Date.now() - hit.timestamp < 2000) { // Only recent hits
                    player.health -= hit.damage;
                    showPowerupPopup('üí• YOU WERE HIT! -' + hit.damage);
                    
                    if (player.health <= 0) {
                        // Notify the killer they got a kill
                        if (hit.from) {
                            database.ref('battle/kills/' + hit.from).push({
                                timestamp: Date.now()
                            });
                        }
                        
                        battleLives--;
                        
                        if (battleLives > 0) {
                            // Respawn with remaining lives
                            player.health = 100;
                            player.x = MAP_WIDTH / 2 + (Math.random() - 0.5) * 400;
                            player.y = MAP_HEIGHT / 2 + (Math.random() - 0.5) * 400;
                            showPowerupPopup('‚ò†Ô∏è LOST A LIFE! ' + battleLives + ' left. Respawning...');
                            // Update lives in Firebase
                            database.ref('battle/players/' + myPlayerId + '/lives').set(battleLives);
                        } else {
                            // No lives left - eliminated! Enter ghost/spectator mode
                            showPowerupPopup('üíÄ ELIMINATED! Spectating...');
                            isEliminated = true;
                            // Store final hits before removing from active players
                            database.ref('battle/finalHits/' + myPlayerId).set({
                                name: brPlayerName,
                                hits: battleHits,
                                gameStart: brGameStartTime
                            });
                            // Remove from active players (so others know we're out)
                            database.ref('battle/players/' + myPlayerId).remove();
                            // Keep syncing position for spectator cam but mark as ghost
                            // gameRunning stays true so we can still move around
                        }
                    }
                }
                // Remove the hit notification
                snapshot.ref.remove();
            });
        }
        
        // Listen for our kills (battle mode)
        function listenForKills() {
            if (!isMultiplayer || multiplayerMode !== 'battle' || !myPlayerId) return;
            
            const killsRef = database.ref('battle/kills/' + myPlayerId);
            killsRef.on('child_added', (snapshot) => {
                const kill = snapshot.val();
                if (kill && Date.now() - kill.timestamp < 2000) {
                    battleKills++;
                    showPowerupPopup('üéØ KILL! (' + battleKills + ' total)');
                }
                snapshot.ref.remove();
            });
        }

        // Initialize demo mode
        initDemo();
    </script>
</body>
</html>